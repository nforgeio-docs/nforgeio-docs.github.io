"use strict";(self.webpackChunkneon_docs=self.webpackChunkneon_docs||[]).push([[67],{8489:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>c,toc:()=>d});var r=n(4848),s=n(8453);const o={sidebar_position:9,displayed_sidebar:"operatorsdk",title:"Best Practices",hide_title:!1,hide_table_of_contents:!1,description:"Best practices to follow when building Operators.",keywords:["operator","sdk","crd","crds","custom resource","resource controller"],last_update:{author:"Marcus Bowyer"}},i="Best Practices",c={id:"operator-sdk/best-practices",title:"Best Practices",description:"Best practices to follow when building Operators.",source:"@site/docs/operator-sdk/best-practices.mdx",sourceDirName:"operator-sdk",slug:"/operator-sdk/best-practices",permalink:"/docs/operator-sdk/best-practices",draft:!1,unlisted:!1,editUrl:"https://github.com/nforgeio/documentation/edit/master/docs/operator-sdk/best-practices.mdx",tags:[],version:"current",sidebarPosition:9,frontMatter:{sidebar_position:9,displayed_sidebar:"operatorsdk",title:"Best Practices",hide_title:!1,hide_table_of_contents:!1,description:"Best practices to follow when building Operators.",keywords:["operator","sdk","crd","crds","custom resource","resource controller"],last_update:{author:"Marcus Bowyer"}},sidebar:"operatorsdk",previous:{title:"Unit Tests",permalink:"/docs/operator-sdk/testing/unit-testing"}},a={},d=[{value:"Implementing a Reconciler",id:"implementing-a-reconciler",level:2},{value:"Idempotency",id:"idempotency",level:3},{value:"Reconcile All Resources All the Time",id:"reconcile-all-resources-all-the-time",level:3},{value:"Owner References",id:"owner-references",level:3}];function l(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(t.h2,{id:"implementing-a-reconciler",children:"Implementing a Reconciler"}),"\n",(0,r.jsx)(t.h3,{id:"idempotency",children:"Idempotency"}),"\n",(0,r.jsxs)(t.p,{children:["Reconcile is called for every event received from the Controller, which could be\nmultiple times for the same resource. This includes listing all resources the\nfirst time the Operator starts or restarts. It is important that reconciliation\nis ",(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Idempotence",children:"idempotent"}),"."]}),"\n",(0,r.jsx)(t.p,{children:"A function is said to be idempotent if it can be applied multiple times without\nchanging the result beyond the initial application."}),"\n",(0,r.jsx)(t.h3,{id:"reconcile-all-resources-all-the-time",children:"Reconcile All Resources All the Time"}),"\n",(0,r.jsx)(t.p,{children:"Reconciliation can be triggered from many different event sources. It could be\ntempting to check the event to try to figure out what needs reconciling, but\nthis is considered to be an anti-pattern for Operators. Because of the\ndistributed nature of Kubernetes, it's possible that the Operator did not\nreceive all events and in this situation making assumptions about the current\nstate could be dangerous. For this reason it is best practice to reconcile all\nresources all the time."}),"\n",(0,r.jsx)(t.h3,{id:"owner-references",children:"Owner References"}),"\n",(0,r.jsx)(t.p,{children:"Dependent objects created by the Reconciler should have an Owner Reference that\nreferences their owner resource. This will allow Kubernetes to clean up\nresources when the parent resource is deleted."}),"\n",(0,r.jsxs)(t.admonition,{type:"info",children:[(0,r.jsx)(t.p,{children:"Cross-namespace owner references are disallowed by design. Namespaced dependents\ncan specify cluster-scoped or namespaced owners. A namespaced owner must exist\nin the same namespace as the dependent. If it does not, the owner reference is\ntreated as absent, and the dependent is subject to deletion once all owners are\nverified absent."}),(0,r.jsx)(t.p,{children:"Cluster-scoped dependents can only specify cluster-scoped owners. In v1.20+, if\na cluster-scoped dependent specifies a namespaced kind as an owner, it is\ntreated as having an unresolvable owner reference, and is not able to be garbage\ncollected."}),(0,r.jsxs)(t.p,{children:["For cross-namespace garbage collection, use a ",(0,r.jsx)(t.a,{href:"./finalizers",children:(0,r.jsx)(t.code,{children:"Finalizer"})}),"."]})]}),"\n",(0,r.jsxs)(t.p,{children:["Owner references can be created by calling the ",(0,r.jsx)(t.code,{children:"MakeOwnerReference()"})," extension\nmethod on any resource."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"var pod = new V1Pod().Initialize()\npod.AddOwnerReference(resource.MakeOwnerReference());\n"})})]})}function p(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>c});var r=n(6540);const s={},o=r.createContext(s);function i(e){const t=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(o.Provider,{value:t},e.children)}}}]);