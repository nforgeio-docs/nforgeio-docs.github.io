"use strict";(self.webpackChunkneon_docs=self.webpackChunkneon_docs||[]).push([[4610],{3448:(e,r,s)=>{s.r(r),s.d(r,{assets:()=>l,contentTitle:()=>o,default:()=>a,frontMatter:()=>i,metadata:()=>d,toc:()=>c});var n=s(4848),t=s(8453);s(4182),s(1801),s(3012),s(7227),s(9489);const i={sidebar_position:8,displayed_sidebar:"neonkube",title:"Network Options",hide_title:!1,hide_table_of_contents:!0,description:"NeonKUBE network options",last_update:{author:"NeonFORGE Team"}},o="Network Options",d={id:"neonkube/cluster-definition/network-options",title:"Network Options",description:"NeonKUBE network options",source:"@site/docs/neonkube/cluster-definition/network-options.mdx",sourceDirName:"neonkube/cluster-definition",slug:"/neonkube/cluster-definition/network-options",permalink:"/docs/neonkube/cluster-definition/network-options",draft:!1,unlisted:!1,editUrl:"https://github.com/nforgeio/documentation/edit/master/docs/neonkube/cluster-definition/network-options.mdx",tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8,displayed_sidebar:"neonkube",title:"Network Options",hide_title:!1,hide_table_of_contents:!0,description:"NeonKUBE network options",last_update:{author:"NeonFORGE Team"}},sidebar:"neonkube",previous:{title:"Monitor Options",permalink:"/docs/neonkube/cluster-definition/monitor-options"},next:{title:"Node Definitions",permalink:"/docs/neonkube/cluster-definition/node-definitions"}},l={},c=[{value:"Address Rules",id:"address-rules",level:2}];function h(e){const r={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r.h1,{id:"network-options",children:"Network Options"}),"\n",(0,n.jsx)(r.p,{children:"Describes the network options for a cluster."}),"\n",(0,n.jsxs)(r.p,{children:["Here's what the network options look like, with the default values or\r\n",(0,n.jsx)(r.strong,{children:"[required]"})," for properties that must be specified:"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-yaml",children:'network:\r\n  acme:\r\n    certificateDuration:    "2160h0m0s"\r\n    certificateRenewBefore: "720h0m0s"\r\n    issuer:                 null\r\n  egressAddressRules:       []\r\n  gateway:                  [second address in premiseSubnet]\r\n  ingressHealthCheck:\r\n    intervalSeconds:        10\r\n    thresholdCount:         2\r\n  ingressRules:             []\r\n  managementAddressRules:   []\r\n  mutalPodTls:              false\r\n  nameServers:\r\n  - "8.8.8.8"               [Google DNS for on-premise]\r\n  - "8.8.4.4"               [otherwise use cloud DNS  ]\r\n  nodeMtu:                  0\r\n  premiseSubnet:            [required for on-premise]\r\n  podSubnet:                "10.254.0.0/16"\r\n  publicAddresses:          []\r\n  reservedIngressEndPort:   64999\r\n  reservedIngressStartPort: 64000\r\n  serviceSubnet:            "10.253.0.0/16"\n'})}),"\n",(0,n.jsxs)("table",{children:[(0,n.jsxs)("thead",{children:[(0,n.jsx)("th",{children:"Property"}),(0,n.jsx)("th",{children:"Description"})]}),(0,n.jsxs)("tr",{children:[(0,n.jsx)("td",{children:(0,n.jsx)("b",{children:"acme.certificateDuration"})}),(0,n.jsx)("td",{children:(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"string:"})," Optionally specifies the maximum lifespan for internal cluster TLS certificates as a GOLANG formatted string.",(0,n.jsx)(r.br,{}),"\n","This defaults to ",(0,n.jsx)(r.strong,{children:"2160h0m0s"})," (90 days)."]})})]}),(0,n.jsxs)("tr",{children:[(0,n.jsx)("td",{children:(0,n.jsx)("b",{children:"acme.certificateRenewBefore"})}),(0,n.jsx)("td",{children:(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"string:"})," Optionally specifies the time to wait before attempting to renew internal cluster TLS certificates.\r\nThis must be less than ",(0,n.jsx)(r.strong,{children:"acme.certificateDuration"})," and defaults to ",(0,n.jsx)(r.strong,{children:"720h0m0s"})," (24 days)."]})})]}),(0,n.jsxs)("tr",{children:[(0,n.jsx)("td",{children:(0,n.jsx)("b",{children:"acme.issuer"})}),(0,n.jsx)("td",{children:(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"string:"})," Optionally specifies the certificate issuer, including any configuration required by the issuer.\r\nThis defaults to ",(0,n.jsx)(r.strong,{children:"null"})," which enables the standard NeonKUBE certificate issuer."]})})]}),(0,n.jsxs)("tr",{children:[(0,n.jsx)("td",{children:(0,n.jsx)("b",{children:"egressAddressRules"})}),(0,n.jsxs)("td",{children:[(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"array:"})," Optionally specifies whitelisted and/or blacklisted external addresses\r\nfor outbound traffic.  This defaults to allowing outbound traffic to anywhere\r\nwhen the property is ",(0,n.jsx)(r.strong,{children:"null"})," or empty.  See ",(0,n.jsx)(r.a,{href:"#address-rules",children:"Address Rules"}),"\r\nbelow for more information."]}),(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"NOTE:"})," Address rules are processed in order from first to last, so you may\r\nconsider putting your blacklist rules before your whitelist rules."]}),(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"NOTE:"})," These rules currently apply to all network ports."]}),(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"NOTE:"})," This is currently supported only for clusters hosted on Azure.  AWS doesn't support\r\nthis scenario and we currently don't support automatic router configuration for\r\non-premise environments."]})]})]}),(0,n.jsxs)("tr",{children:[(0,n.jsx)("td",{children:(0,n.jsx)("b",{children:"gatewy"})}),(0,n.jsxs)("td",{children:[(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"string:"})," Specifies the default network gateway address to be configured for cluster nodes.\r\nThis defaults to the  second usable address in the ",(0,n.jsx)(r.strong,{children:"premiseSubnet"}),".  For example,\r\nfor the ",(0,n.jsx)(r.strong,{children:"10.0.0.0/24"})," subnet, this will be default to ",(0,n.jsx)(r.strong,{children:"10.0.0.1"}),"."]}),(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"NOTE:"})," This applies only to on-premise deployments and ignored for cloud hosting."]})]})]}),(0,n.jsxs)("tr",{children:[(0,n.jsx)("td",{children:(0,n.jsx)("b",{children:"ingressRules"})}),(0,n.jsxs)("td",{children:[(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"array:"})," Optionally specifies the ingress routing rules for external traffic received by nodes\r\nwith ",(0,n.jsx)(r.strong,{children:"node.Ingress=true"})," enabled, targeting one or more Istio ingress gateway services\r\nwhich are then responsible for routing to the target Kubernetes services."]}),(0,n.jsxs)(r.p,{children:["This defaults to allowing inbound ",(0,n.jsx)(r.strong,{children:"HTTP/HTTPS"})," traffic and cluster setup\r\nalso adds a TCP rule for the Kubernetes API server on port ",(0,n.jsx)(r.strong,{children:"6442"}),"."]}),(0,n.jsx)(r.p,{children:"Here's how an address rule is structured:"}),(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-yaml",children:"addressRules:          []\r\nexternalPort:          [required]\r\ningressHealthCheck:\r\n    intervalSeconds:     10\r\n    thresholdCount:      2\r\nname:                  [required]\r\nnodePort:              [required]\r\nprotocol:              tcp\r\ntargetPort:            0\r\ntcpIdleReset:          true\r\ntcpIdleTimeoutMinutes: 4\n"})}),(0,n.jsxs)("table",{children:[(0,n.jsxs)("thead",{children:[(0,n.jsx)("th",{children:"Property"}),(0,n.jsx)("th",{children:"Description"})]}),(0,n.jsxs)("tr",{children:[(0,n.jsx)("td",{children:(0,n.jsx)("b",{children:"addressRules"})}),(0,n.jsxs)("td",{children:[(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"array:"})," Optionally specifies whitelisted and/or blacklisted external addresses\r\nfor inbound traffic.  This defaults to allowing inbound traffic from anywhere\r\nwhen the property is ",(0,n.jsx)(r.strong,{children:"null"})," or empty.    See ",(0,n.jsx)(r.a,{href:"#address-rules",children:"Address Rules"}),"\r\nbelow for more information."]}),(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"NOTE:"})," Address rules are processed in order, from first to last so you may consider\r\nputting your blacklist rules before your whitelist rules."]}),(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"NOTE:"})," This is currently supported only for clusters hosted on Azure.  AWS doesn't support\r\nthis scenario and we currently don't support automatic router configuration for\r\non-premise environments."]})]})]}),(0,n.jsxs)("tr",{children:[(0,n.jsx)("td",{children:(0,n.jsx)("b",{children:"externalPort"})}),(0,n.jsx)("td",{children:(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"integer:"})," Specifies the external ingress port used to handle external (generally Internet) traffic\r\nreceived by the cluster load balancer."]})})]}),(0,n.jsxs)("tr",{children:[(0,n.jsx)("td",{children:(0,n.jsx)("b",{children:"ingressHealthCheck"})}),(0,n.jsxs)("td",{children:[(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"intervalSeconds:"})," ",(0,n.jsx)(r.code,{children:"integer"}),": Specifies the interval in seconds between load balancer health\r\nchecks.  This defaults to ",(0,n.jsx)("b",{children:"10 seconds"})," and must be in the range of ",(0,n.jsx)(r.strong,{children:"10...300"})," seconds."]}),(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"thresholdCount:"})," ",(0,n.jsx)(r.code,{children:"integer:"})," Specifies the number of consecutive failed health checks before\r\nthe load balancer will consider the node endpoint to be unhealthy.  This defaults to ",(0,n.jsx)(r.strong,{children:"2"})," and\r\nmust be in the range of ",(0,n.jsx)(r.strong,{children:"2...10"})]})]})]}),(0,n.jsxs)("tr",{children:[(0,n.jsx)("td",{children:(0,n.jsx)("b",{children:"name"})}),(0,n.jsx)("td",{})]}),(0,n.jsxs)("tr",{children:[(0,n.jsx)("td",{children:(0,n.jsx)("b",{children:"nodePort"})}),(0,n.jsx)("td",{children:(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"integer:"})," Specifies the port on cluster nodes where external traffic received by the load balancer\r\non ",(0,n.jsx)(r.strong,{children:"externalPort"})," will be forwarded.  The cluster's ingress gateway (Istio) will be\r\nconfigured to listen for traffic on this port and route it into the cluster."]})})]}),(0,n.jsxs)("tr",{children:[(0,n.jsx)("td",{children:(0,n.jsx)("b",{children:"protocol"})}),(0,n.jsxs)("td",{children:[(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"string:"})," Optionally specifies the network protocol.  Supported values are: ",(0,n.jsx)(r.strong,{children:"http"}),", ",(0,n.jsx)(r.strong,{children:"https"}),",\r\n",(0,n.jsx)(r.strong,{children:"tcp"}),", or ",(0,n.jsx)(r.strong,{children:"udp"}),"."]}),(0,n.jsxs)(r.p,{children:["This defaults to ",(0,n.jsx)(r.strong,{children:"tcp"}),"."]})]})]}),(0,n.jsxs)("tr",{children:[(0,n.jsx)("td",{children:(0,n.jsx)("b",{children:"targetPort"})}),(0,n.jsxs)("td",{children:[(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"integer:"})," Specifies the target ingress port internal to the cluster.  The cluster's ingress gateway\r\n(Istio) applies routing rules (virtual service) to the network traffic as it was received on\r\n",(0,n.jsx)(r.strong,{children:"targetPort"}),".  This decouples routing rules from ",(0,n.jsx)(r.strong,{children:"nNodePort"})," which may change for different\r\nhosting environments."]}),(0,n.jsxs)(r.p,{children:["This property is optional and defaults to zero, indicating that the traffic should\r\nbe routed to just the node port but ",(0,n.jsx)(r.strong,{children:"should not be routed through ingress gateway"}),".\r\nThis is useful for handling ",(0,n.jsx)(r.strong,{children:"UDP traffic"})," which Istio doesn't currently support and\r\nperhaps some other scenarios."]})]})]}),(0,n.jsxs)("tr",{children:[(0,n.jsx)("td",{children:(0,n.jsx)("b",{children:"tcpIdleReset"})}),(0,n.jsxs)("td",{children:[(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"bool:"})," Optionally specifies whether the cluster router or load balancer sends a TCP RESET\r\npacket to both ends of a TCP connection that has been idle for longer than ",(0,n.jsx)(r.strong,{children:"tcpIdleTimeoutMinutes"}),".\r\nThis defaults to ",(0,n.jsx)(r.strong,{children:"true"}),"."]}),(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"NOTE:"})," At this point, this property is supported only in cloud environments where we\r\ncan easily control the cluster's external loag balancer.  This also has no\r\nimpact for the ",(0,n.jsx)(r.strong,{children:"udp"})," protocol."]})]})]}),(0,n.jsxs)("tr",{children:[(0,n.jsx)("td",{children:(0,n.jsx)("b",{children:"tcpIdleTimeoutMinutes"})}),(0,n.jsxs)("td",{children:[(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"integer:"})," Optionally specifies the TCP idle time out for TCP related ingress protocols like\r\n",(0,n.jsx)(r.strong,{children:"http"}),", ",(0,n.jsx)(r.strong,{children:"https"}),", and ",(0,n.jsx)(r.strong,{children:"tcp"}),".  Inbound TCP connections that have no network\r\ntraffic going either way will be closed by supported load balancers or routers.\r\nThis defaults to ",(0,n.jsx)(r.strong,{children:"4 minutes"}),"."]}),(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"NOTE:"})," At this point, this property is supported only in cloud environments where we\r\ncan easily control the cluster's external loag balancer.  This also has no impact for non-TCP rules."]}),(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"NOTE:"})," Cluster setup may modify this value to ensure that it honors the range of\r\nvalues supported by the target cloud cloud."]})]})]})]})]})]}),(0,n.jsxs)("tr",{children:[(0,n.jsx)("td",{children:(0,n.jsx)("b",{children:"managementAddressRules"})}),(0,n.jsxs)("td",{children:[(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"array:"})," Optionally specifies whitelisted and/or blacklisted external addresses for\r\nnode management via SSH NAT rules as well as cluster management via the\r\nKubernetes API via port 6443.  This defaults to allowing inbound traffic\r\nfrom anywhere when the property is ",(0,n.jsx)("c",{children:"null"})," or empty.  See ",(0,n.jsx)(r.a,{href:"#address-rules",children:"Address Rules"}),"\r\nbelow for more information."]}),(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"NOTE:"})," Address rules are processed in order from first to last, so you may\r\nconsider putting your blacklist rules before your whitelist rules."]}),(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"NOTE:"})," This is currently supported only for clusters hosted on Azure.  AWS doesn't support\r\nthis scenario and we currently don't support automatic router configuration for\r\non-premise environments."]})]})]}),(0,n.jsxs)("tr",{children:[(0,n.jsx)("td",{children:(0,n.jsx)("b",{children:"mutalPodTls"})}),(0,n.jsx)("td",{children:(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"bool:"})," Optionally enables Istio mutual TLS support for cross pod communication.\r\nThis defaults to ",(0,n.jsx)(r.strong,{children:"false"}),"."]})})]}),(0,n.jsxs)("tr",{children:[(0,n.jsx)("td",{children:(0,n.jsx)("b",{children:"nameServers"})}),(0,n.jsxs)("td",{children:[(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"array:"})," Optionally specifies the IP addresses of the DNS nameservers to be used by the cluster."]}),(0,n.jsxs)(r.p,{children:["For cloud environments, this defaults the name servers provided by the cloud.  For on-premise\r\nenvironments, this defaults to the ",(0,n.jsx)(r.a,{href:"https://developers.google.com/speed/public-dns",children:"Google Public DNS"}),"\r\nservers: ",(0,n.jsx)(r.strong,{children:'["8.8.8.8", "8.8.4.4" ]'}),"."]})]})]}),(0,n.jsxs)("tr",{children:[(0,n.jsx)("td",{children:(0,n.jsx)("b",{children:"nodeMtu"})}),(0,n.jsxs)("td",{children:[(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"integer:"})," Optionally overrides the default MTU (maximum transmission unit)\r\nconfigured for luster node network interfaces.  The default MTU for the hosting environment\r\nwill be used when set to ",(0,n.jsx)(r.strong,{children:"0"}),", otherwise this can be configured as a value between ",(0,n.jsx)(r.strong,{children:"512-9000"}),".\r\nThis defaults to: ",(0,n.jsx)(r.strong,{children:"0"})]}),(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"WARNING:"})," This is an ",(0,n.jsx)(r.strong,{children:"advanced setting"}),".  Only people who really know\r\nwhat they're doing should change this."]})]})]}),(0,n.jsxs)("tr",{children:[(0,n.jsx)("td",{children:(0,n.jsx)("b",{children:"premiseSubnet"})}),(0,n.jsx)("td",{children:(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"string:"})," Specifies the subnet for LAN for on-premise deployments.  This is\r\nrequired for on-premise and is ignored for cloud deployments."]})})]}),(0,n.jsxs)("tr",{children:[(0,n.jsx)("td",{children:(0,n.jsx)("b",{children:"podSubnet"})}),(0,n.jsx)("td",{children:(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"string:"})," Optionally specifies the subnet used for cluster pods.  This subnet will be\r\nsplit so that each node will be allocated its own subnet for the pods running there.\r\nThis defaults to (",(0,n.jsx)(r.strong,{children:")10.254.0.0/16"}),"."]})})]}),(0,n.jsxs)("tr",{children:[(0,n.jsx)("td",{children:(0,n.jsx)("b",{children:"publicAddresses"})}),(0,n.jsxs)("td",{children:[(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"array:"})," Optionally specifies the public IP addresses for the cluster.  This is useful\r\nfor documenting the public IP address for a router that directs traffic\r\ninto the cluster."]}),(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"NOTE:"})," This property is informational only and does not affect cluster deployments."]})]})]}),(0,n.jsxs)("tr",{children:[(0,n.jsx)("td",{children:(0,n.jsx)("b",{children:"reservedIngressEndPort"})}),(0,n.jsxs)("td",{children:[(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"integer:"})," Optionally specifies the end of a range of ingress load balancer ports\r\nreserved by NeonKUBE.  These are reserved for temporarily exposing SSH from individual\r\ncluster nodes to the Internet during cluster setup as well as afterwards so that a\r\ncluster node can be accessed remotely by a cluster operator as well as for other\r\npurposes and for potential future features such as an integrated"]}),(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"NOTE:"})," The number ports between ",(0,n.jsx)(r.strong,{children:"reservedIngressStartPort"})," and ",(0,n.jsx)(r.strong,{children:"reservedIngressEndPort"}),"\r\nmust include at least as many ports as there will be nodes deployed to the cluster\r\nfor the temporary SSH NAT rules plus another 100 ports reserved for other purposes.\r\nThis range defaults to ",(0,n.jsx)(r.strong,{children:"64000-64999"})," which will support a cluster with up to\r\n900 nodes.  This default range is unlikely to conflict with ports a cluster is likely\r\nto need expose to the Internet like HTTP/HTTPS (80/443).  You can change this range\r\nfor your cluster to resolve any conflicts when necessary."]})]})]}),(0,n.jsxs)("tr",{children:[(0,n.jsx)("td",{children:(0,n.jsx)("b",{children:"reservedIngressStartPort"})}),(0,n.jsxs)("td",{children:[(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"integer:"})," Optionally specifies the end of a range of ingress load balancer ports\r\nreserved by NeonKUBE.  These are reserved for temporarily exposing SSH from individual\r\ncluster nodes to the Internet during cluster setup as well as afterwards so\r\nthat a cluster node can be accessed remotely by a cluster operator as well\r\nas for other purposes and for potential future features such as an integrated"]}),(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"NOTE:"})," The number ports between ",(0,n.jsx)(r.strong,{children:"reservedIngressStartPort"})," and ",(0,n.jsx)(r.strong,{children:"reservedIngressEndPort"}),"\r\nmust include at least as many ports as there will be nodes deployed to the cluster\r\nfor the temporary SSH NAT rules plus another 100 ports reserved for other purposes.\r\nThis range defaults to ",(0,n.jsx)(r.strong,{children:"64000-64999"})," which will support a cluster with up to\r\n900 nodes.  This default range is unlikely to conflict with ports a cluster is likely\r\nto need expose to the Internet like HTTP/HTTPS (80/443).  You can change this range\r\nfor your cluster to resolve any conflicts when necessary."]})]})]})]}),"\n",(0,n.jsx)(r.h2,{id:"address-rules",children:"Address Rules"}),"\n",(0,n.jsx)("a",{name:"address-rules"}),"\n",(0,n.jsxs)(r.p,{children:["Address rules can be used white or blacklist external traffic to or from the\r\ncluster. The network ",(0,n.jsx)(r.strong,{children:"egressAddressRules"}),", ",(0,n.jsx)(r.strong,{children:"ingressRules"}),", and\r\n",(0,n.jsx)(r.strong,{children:"managementAddressRules"})," properties above may be set to an array of address\r\nrules to allow or deny traffic for a specific IP address or subnet."]}),"\n",(0,n.jsxs)(r.p,{children:["Here's what an address rule looks like, with the default values or\r\n",(0,n.jsx)(r.strong,{children:"[required]"})," for properties that must be specified:"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-yaml",children:"action:          [required]\r\naddressOrSubnet: [required]\n"})}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"addressOrSubnet"})," specifies can specify a single IP address or a CIDR/subnet\r\nspecifying a range of IP addresses. This can also be set to ",(0,n.jsx)(r.strong,{children:'"any"'})," which\r\nmatches all possible IP addresses."]}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"action"})," can be set to ",(0,n.jsx)(r.strong,{children:"allow"})," or ",(0,n.jsx)(r.strong,{children:"deny"}),", where ",(0,n.jsx)(r.strong,{children:"allow"})," lets network\r\nflow for the IP address(es) and ",(0,n.jsx)(r.strong,{children:"deny"})," blocks the traffic."]}),"\n",(0,n.jsx)(r.p,{children:"Rules are applied in the order they appear in the list where the first rule that\r\napplies to the traffic's IP address will be applied. Traffic will be allowed\r\nwhen no rule matches."})]})}function a(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}}}]);