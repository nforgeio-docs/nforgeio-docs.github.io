"use strict";(self.webpackChunkneon_docs=self.webpackChunkneon_docs||[]).push([[3892],{2046:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>d,toc:()=>c});var r=n(4848),i=n(8453);n(4182),n(1801),n(3012),n(7227),n(9489);const t={sidebar_position:9,displayed_sidebar:"neonkube",title:"Node Definitions",hide_title:!1,hide_table_of_contents:!0,description:"Describing NeonKUBE cluster nodes",last_update:{author:"NEONFORGE Team"}},o="Node Definitions",d={id:"neonkube/cluster-definition/node-definitions",title:"Node Definitions",description:"Describing NeonKUBE cluster nodes",source:"@site/docs/neonkube/cluster-definition/node-definitions.mdx",sourceDirName:"neonkube/cluster-definition",slug:"/neonkube/cluster-definition/node-definitions",permalink:"/docs/neonkube/cluster-definition/node-definitions",draft:!1,unlisted:!1,editUrl:"https://github.com/nforgeio/documentation/edit/master/docs/neonkube/cluster-definition/node-definitions.mdx",tags:[],version:"current",sidebarPosition:9,frontMatter:{sidebar_position:9,displayed_sidebar:"neonkube",title:"Node Definitions",hide_title:!1,hide_table_of_contents:!0,description:"Describing NeonKUBE cluster nodes",last_update:{author:"NEONFORGE Team"}},sidebar:"neonkube",previous:{title:"Network Options",permalink:"/docs/neonkube/cluster-definition/network-options"},next:{title:"Node Options",permalink:"/docs/neonkube/cluster-definition/node-options"}},l={},c=[];function a(e){const s={a:"a",code:"code",em:"em",h1:"h1",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.h1,{id:"node-definitions",children:"Node Definitions"}),"\n",(0,r.jsx)(s.p,{children:"Describes the machines that need to be deployed for a NeonKUBE cluster. This is a map with the machine hostnames mapping\r\nto an object specifying the requirements for each cluster node."}),"\n",(0,r.jsxs)(s.p,{children:["Here's what the node options look like, with the default values or ",(0,r.jsx)(s.strong,{children:"[required]"})," for properties that must be specified:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-yaml",children:'nodes:\r\n  my-node: {\r\n    address:               null\r\n    aws:\r\n      instanceType:        null\r\n      ebsOptimized:        "default"\r\n      placementPartition:  0\r\n      volumeSize:          "default"\r\n      storageType:         "default"\r\n      diskSize:            null\r\n      openEbsVolumeSize:   "default"\r\n      openEbsStorageType:  "default"\r\n      openEbsdiskSize:     null\r\n    azure:\r\n      vmSize:              null\r\n      storageType:         "default"\r\n      diskSize:            null\r\n      openEbsStorageType: "default"\r\n      openEbsDiskSize:     null\r\n    hypervisor:\r\n      host:                null\r\n      vcpus:               0\r\n      memory:              null\r\n      osDisk:              null\r\n      openEbsDisk:         null\r\n    ingress:               false\r\n    role:                  "worker"\r\n    openEbsStorage:        false\r\n    taints:                []\r\n  }\r\n}\n'})}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.strong,{children:"address"})," property is required for on-premise hosting environments like ",(0,r.jsx)(s.strong,{children:"Hyper-V"})," and ",(0,r.jsx)(s.strong,{children:"XenServer/XCP-ng"}),". This\r\nis optional for cloud environments like ",(0,r.jsx)(s.strong,{children:"AWS"})," and ",(0,r.jsx)(s.strong,{children:"Azure"})," where NeonKUBE will automatically assign IP addresses to\r\nnode, but you can also assign addresses to cloud nodes explicitly if you wish."]}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.strong,{children:"aws"}),", ",(0,r.jsx)(s.strong,{children:"azure"}),", and ",(0,r.jsx)(s.strong,{children:"hypervisor"})," allow you to override settings from the global cluster definition\r\n",(0,r.jsx)(s.strong,{children:"hosting.aws"}),", ",(0,r.jsx)(s.strong,{children:"hosting.azure"}),", ",(0,r.jsx)(s.strong,{children:"hosting.hyperv"})," and ",(0,r.jsx)(s.strong,{children:"hosting.xenserver"})," properties for individual cluster\r\nnodes."]}),"\n",(0,r.jsxs)("table",{children:[(0,r.jsxs)("thead",{children:[(0,r.jsx)("th",{children:"Property"}),(0,r.jsx)("th",{children:"Description"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)(s.strong,{children:"address"})}),(0,r.jsxs)("td",{children:[(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"string:"})," Specifies the IP address to be assinged to the node or ",(0,r.jsx)(s.strong,{children:"null"})," if addresses are\r\nto be automatically assigned durining cluster setup."]}),(0,r.jsx)(s.p,{children:"This is required for on-premise clusters deployed to Hype-V or XenServer/XCP-ng\r\nbut is optional for cloud deployments."})]})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)(s.strong,{children:"aws"})}),(0,r.jsxs)("td",{children:[(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"object:"})," ",(0,r.jsx)(s.strong,{children:"AWS"})," specific options for the cluster node.  These options can be used to override\r\ndefaults specified by ",(0,r.jsx)(s.strong,{children:"hosting.aws"})," in the cluster definition.  This is ignored\r\nfor non-AWS deployments."]}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-yaml",children:'aws:\r\n    ebsOptiomized:     "default"\r\n    instanceType:      null\r\n    placementPartition:    0\r\n    openEbsVolumeSize: null\r\n    openEbsVolumeType: "default"\r\n    volumeSize:        null\r\n    volumeType:        "default"\n'})}),(0,r.jsxs)("table",{children:[(0,r.jsxs)("thead",{children:[(0,r.jsx)("th",{children:"Property"}),(0,r.jsx)("th",{children:"Description"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)(s.strong,{children:"ebsOptiomized"})}),(0,r.jsxs)("td",{children:[(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"string:"})," Non EBS optimized instances perform disk operation I/O to EBS volumes using the same\r\nnetwork used for other network operations.  This means that you may see some disk\r\nperformance declines when your instance is busy serving web traffic or running\r\ndatabase queries, etc."]}),(0,r.jsx)(s.p,{children:"EBS optimization can be enabled for some instance types.  This provisions extra dedicated\r\nnetwork bandwidth exclusively for EBS I/O.  Exactly how this works, depends on the specific\r\nVM type."}),(0,r.jsxs)(s.p,{children:["More modern AWS VM types enable EBS optimization by default and you won't incur any\r\nadditional charges for these instances and disabling EBS optimization here or via\r\n",(0,r.jsx)("see",{cref:"AwsHostingOptions.DefaultEbsOptimized"})," won't have any effect."]}),(0,r.jsxs)(s.p,{children:["Some AWS instance types can be optimized but this is disabled by default.  When you\r\nenable this by setting the cluster definition's ",(0,r.jsx)(s.strong,{children:"hosting.aws.defaultEbsOptimized"})," or\r\nthis (",(0,r.jsx)(s.strong,{children:"ebsOptiomized"}),') property to "true", you\'ll probably an additional AWS hourly fee for\r\nthese instances.']}),(0,r.jsxs)(s.p,{children:["Some AWS instance types don't support EBS optimization.  You'll need take care to disable\r\n",(0,r.jsx)(s.strong,{children:"ebsOptiomized"})," for those nodes."]})]})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)(s.strong,{children:"instanceType"})}),(0,r.jsxs)("td",{children:[(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"string:"})," Optionally specifies the type of ECB instance to provision for this node.\r\nSee ",(0,r.jsx)(s.a,{href:"https://aws.amazon.com/ec2/instance-types/",children:"AWS Instance Types"})," for the instance\r\ntypes currently supported by AWS."]}),(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"NOTE:"})," NeonKUBE clusters cannot be deployed to ARM-based AWS instance types.  You must\r\nspecify an instance type using a Intel or AMD 64-bit processor."]}),(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"NOTE:"})," NeonKUBE requires control-plane and worker instances to have at least 4 CPUs\r\nand 8GiB RAM.  Choose an AWS instance type that satisfies these requirements."]})]})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)(s.strong,{children:"placementPartition"})}),(0,r.jsxs)("td",{children:[(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"integer:"})," Optionally specifies the AWS placement group partition the node will be provisioned\r\nwithin.  This is a ",(0,r.jsx)(s.strong,{children:"1-based"})," partition index which ",(0,r.jsx)(s.strong,{children:"defaults to 0"}),", indicating\r\nthat node placement will be handled automatically by AWS."]}),(0,r.jsxs)(s.p,{children:["You generally don't need to customize this for control-plane nodes since there will generally\r\nbe a separate partition available for each control-plane and AWS will spread the instances\r\nacross these automatically.  When you specify this for control-plane nodes, the partition index\r\nmust be in the range of ",(0,r.jsx)(s.strong,{children:"1...hosting.aws.controlPlanePlacementPartitions"}),"."]}),(0,r.jsx)(s.p,{children:"For some cluster scenarios like a noSQL database cluster, you may wish to explicitly\r\ncontrol the partition where specific worker nodes are provisioned.  For example, if\r\nyour database replcates data across multiple worker nodes, you'd like to have the\r\nworkers hosting the same data be provisioned to different partitions such that if\r\nthe workers in one partition are lost then the workers in the remaining partitions\r\nwill still be able to serve the data."}),(0,r.jsxs)(s.p,{children:["When you specify this for worker nodes, the partition index must be in the range\r\nof ",(0,r.jsx)(s.strong,{children:"1...hosting.aws.workerPlanePlacementPartitions"}),"."]})]})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)(s.strong,{children:"openEbsVolumeSize"})}),(0,r.jsx)("td",{children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"string:"})," Optionally specifies the AWS volume type to be used for the node's OpenEBS cStor/Maystor\r\ndisk (if any).  This defaults to ",(0,r.jsx)(s.strong,{children:"null"})," indicating that ",(0,r.jsx)(s.strong,{children:"hosting.aws.defaultOpenEbsVolumeSize"}),"\r\nwill specify the volume type for the node."]})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)(s.strong,{children:"openEbsVolumeType"})}),(0,r.jsxs)("td",{children:[(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"string:"})," Optionally specifies the size of the AWS volume to be used for the node's OpenEBS\r\ncStor/Maystor disk (if any).  Supported values are ",(0,r.jsx)(s.strong,{children:"default"}),", ",(0,r.jsx)(s.strong,{children:"st"}),", ",(0,r.jsx)(s.strong,{children:"sc1"}),", ",(0,r.jsx)(s.strong,{children:"gp2"}),", ",(0,r.jsx)(s.strong,{children:"io1"}),", or ",(0,r.jsx)(s.strong,{children:"io2"}),'.\r\nThis defaults to **default" indicating that ',(0,r.jsx)(s.strong,{children:"hosting.aws.defaultOpenEbsVolumeType"}),"\r\nwill be used for the node."]}),(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"NOTE:"})," Node disks smaller than 64 GiB are not supported by NeonKUBE.  We'll automatically\r\nupgrade the disk size when necessary."]})]})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)(s.strong,{children:"volumeSize"})}),(0,r.jsxs)("td",{children:[(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"string:"})," Optionally specifies the size of the AWS volume to be used as the node's primary operating\r\nsystem disk.  This defaults to ",(0,r.jsx)(s.strong,{children:"null"})," indicated that ",(0,r.jsx)(s.strong,{children:"hosting.aws.defaultvolumeSize"}),"\r\nwill be used."]}),(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"NOTE:"})," Node disks smaller than 64 GiB are not supported by NeonKUBE.  We'll automatically\r\nround up the disk size when necessary."]})]})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)(s.strong,{children:"volumeType"})}),(0,r.jsx)("td",{children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"string:"})," Optionally specifies the AWS volume type to be used for the node's OpenEBS cStor/Mayastor\r\ndisk (if any).  Supported values are ",(0,r.jsx)(s.strong,{children:"default"}),", ",(0,r.jsx)(s.strong,{children:"st"}),", ",(0,r.jsx)(s.strong,{children:"sc1"}),", ",(0,r.jsx)(s.strong,{children:"gp2"}),", ",(0,r.jsx)(s.strong,{children:"io1"}),", or ",(0,r.jsx)(s.strong,{children:"io2"}),".\r\nThis defaults to ",(0,r.jsx)(s.strong,{children:"default"})," indicating that ",(0,r.jsx)(s.strong,{children:"hosting.aws.defaultvolumeType"}),"\r\nwill specify the volume type for the node."]})})]})]})]})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)(s.strong,{children:"azure"})}),(0,r.jsxs)("td",{children:[(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"object:"})," ",(0,r.jsx)(s.strong,{children:"Azure"})," specific options for the cluster node.  These options can be used to override\r\ndefaults specified by ",(0,r.jsx)(s.strong,{children:"hosting.azure"})," in the cluster definition.  This is ignored\r\nfor non-Azure deployments."]}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-yaml",children:'azure:\r\n    diskSize:           null\r\n    openEbsStorageType: "default"\r\n    openEbsDiskSize:    null\r\n    storageType:        "default"\r\n    vmSize:             "default"\n'})}),(0,r.jsxs)("table",{children:[(0,r.jsxs)("thead",{children:[(0,r.jsx)("th",{children:"Property"}),(0,r.jsx)("th",{children:"Description"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)(s.strong,{children:"diskSize"})}),(0,r.jsxs)("td",{children:[(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"string:"})," Optionally specifies the size of the Azure disk to be used as the node's\r\nprimary operating system disk.  This defaults to ",(0,r.jsx)(s.strong,{children:"null"})," indicating that\r\n",(0,r.jsx)(s.strong,{children:"hosting.azure.defaultDiskSize"})," from the cluster definition will be used."]}),(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"NOTE:"})," Node disks smaller than 64 GiB are not supported by NeonKUBE.  We'll\r\nautomatically round up the disk size when necessary."]})]})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)(s.strong,{children:"openEbsStorageType"})}),(0,r.jsx)("td",{children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"string:"}),"  Optionally specifies the Azure storage type to be used for the node's OpenEBS\r\ncStor/Mayastor disk (if any).  Supported values are ",(0,r.jsx)(s.strong,{children:"default"}),", ",(0,r.jsx)(s.strong,{children:"standard0hhd"}),", ",(0,r.jsx)(s.strong,{children:"standard-ssd"}),",\r\n",(0,r.jsx)(s.strong,{children:"premium-ssd"}),", ",(0,r.jsx)(s.strong,{children:"premium-ssd-v2"}),", and ",(0,r.jsx)(s.strong,{children:"ultra-ssd"}),".  This defaults to ",(0,r.jsx)(s.strong,{children:"default"})," indicating\r\nthat ",(0,r.jsx)(s.strong,{children:"hosting.azure.openEbsStorageType"})," from the cluster definition will be used."]})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)(s.strong,{children:"openEbsDiskSize"})}),(0,r.jsxs)("td",{children:[(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"string:"})," Optionally specifies the size of the Azure disk to be used for the node's OpenEBS\r\ncStor/Mayastor disk (if any).  This defaults to ",(0,r.jsx)(s.strong,{children:"null"})," indicating that **",(0,r.jsx)(s.strong,{children:"hosting.azure.openEbsDiskSize"})]}),(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"NOTE:"})," Node disks smaller than 64 GiB are not supported by NeonKUBE.  We'll automatically\r\nround up the disk size when necessary."]})]})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)(s.strong,{children:"storageType"})}),(0,r.jsx)("td",{children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"string:"})," Optionally specifies the storage type to use the node's primary disk.\r\nSupported values are ",(0,r.jsx)(s.strong,{children:"default"}),", ",(0,r.jsx)(s.strong,{children:"standard0hhd"}),", ",(0,r.jsx)(s.strong,{children:"standard-ssd"}),", ",(0,r.jsx)(s.strong,{children:"premium-ssd"}),",\r\n",(0,r.jsx)(s.strong,{children:"premium-ssd-v2"}),", and ",(0,r.jsx)(s.strong,{children:"ultra-ssd"}),".  This defaults to ",(0,r.jsx)(s.strong,{children:"default"})," indicating\r\nthat ",(0,r.jsx)(s.strong,{children:"hosting.azure.storageType"})," from the cluster definition will be used."]})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)(s.strong,{children:"vmSize"})}),(0,r.jsxs)("td",{children:[(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"string:"})," Optionally specifies the Azure virtual machine size.  Here's a list of the\r\navailable ",(0,r.jsx)(s.a,{href:"https://docs.microsoft.com/en-us/azure/virtual-machines/sizes-general",children:"Azure VM Sizes"}),".\r\nThis dwefaults to ",(0,r.jsx)(s.strong,{children:"default"})," indicating that ",(0,r.jsx)(s.strong,{children:"hosting.azure.vmSize"})," from the\r\ncluster definition will be used."]}),(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"NOTE:"})," NeonKUBE clusters cannot be deployed to ARM-based Azure V, sizes at this time.  You must\r\nspecify an VM size using a Intel or AMD 64-bit processor."]}),(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"NOTE:"})," NeonKUBE requires control-plane and worker instances to have at least 4 CPUs and 8GiB RAM.\r\nChoose an Azure VM size instance type that satisfies these requirements."]})]})]})]})]})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)(s.strong,{children:"hypervisor"})}),(0,r.jsx)("td",{children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"object:"})," on-premsise hypervisor specific options for the cluster node.  These options\r\ncan be used to override defaults specified by ",(0,r.jsx)(s.strong,{children:"hosting.azure"})," in the cluster definition.\r\nThis is ignored clpoud deployments."]})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)(s.strong,{children:"ingress"})}),(0,r.jsxs)("td",{children:[(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"bool:"})," Optionally specifies that this node should be configured to receive external network\r\ntraffic on node ports and route that into the cluster.  This defaults to ",(0,r.jsx)(s.strong,{children:"false"}),"."]}),(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"NOTE:"})," If all nodes have ",(0,r.jsx)(s.strong,{children:"ingress: false"})," and the cluster defines one or more\r\n",(0,r.jsx)(s.strong,{children:"network.ingressRules"})," then NeonKUBE will choose a reasonable set of nodes to handle\r\ninbound traffic."]})]})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)(s.strong,{children:"role"})}),(0,r.jsx)("td",{children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"string:"})," Optionally spoecifies the node's role in the cluster, supported values are ",(0,r.jsx)(s.strong,{children:"control-plane"}),"\r\nor *",(0,r.jsx)(s.em,{children:"worker"}),"  This defaults to ",(0,r.jsx)(s.strong,{children:"worker"}),"."]})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)(s.strong,{children:"openEbsStorage"})}),(0,r.jsxs)("td",{children:[(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"bool:"})," Optionally specifies that this node will provisioned with a cStor or Mayastor\r\nblock device on this node for persistant container storage.  This defaults to ",(0,r.jsx)(s.strong,{children:"false"}),"."]}),(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"NOTE:"}),"  When all nodes have ",(0,r.jsx)(s.strong,{children:"openEbsStorage"})," set to ",(0,r.jsx)(s.strong,{children:"false"}),", NeonKUBE\r\nwill automatically choose the nodes that will host the cStor/Mayastor block devices\r\nby configuring up to three nodes with ",(0,r.jsx)(s.strong,{children:"openEbsStorage: true"}),", favoring worker nodes o\r\nver control-plane nodes when possible."]}),(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"NOTE:"})," When all nodes have **openEbsStorage set to ",(0,r.jsx)(s.strong,{children:"false"})," and ",(0,r.jsx)(s.strong,{children:"storage.openEbs.engine"}),"\r\nin the cluster definitions is set to ",(0,r.jsx)(s.strong,{children:"cstor"})," or ",(0,r.jsx)(s.strong,{children:"mayastor"}),", NeonKUBE will automatically\r\nchoose the nodes that will host the cStor/Maystor block devices by configuring up to three nodes to\r\ndo this, favoring ",(0,r.jsx)(s.strong,{children:"worker"})," nodes over ",(0,r.jsx)(s.strong,{children:"control-plane"})," nodes when possible."]})]})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)(s.strong,{children:"taints"})}),(0,r.jsx)("td",{children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"array:"})," Optionally specifies any taints to be assigned to the cluster node."]})})]})]})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}}}]);