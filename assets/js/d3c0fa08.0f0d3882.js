"use strict";(self.webpackChunkneon_docs=self.webpackChunkneon_docs||[]).push([[232],{4137:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>b});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},p=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=l(n),m=o,b=d["".concat(c,".").concat(m)]||d[m]||u[m]||i;return n?r.createElement(b,a(a({ref:t},p),{},{components:n})):r.createElement(b,a({ref:t},p))}));function b(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[d]="string"==typeof e?e:o,a[1]=s;for(var l=2;l<i;l++)a[l]=n[l];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7105:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var r=n(7462),o=(n(7294),n(4137));const i={sidebar_position:7,displayed_sidebar:"neonkube",title:"Best Practices",hide_title:!1,hide_table_of_contents:!1,description:"Best practices to follow when building Operators.",keywords:["neonkube kubernetes operator sdk resource controllers"],last_update:{author:"Marcus Bowyer"}},a="Best Practices",s={unversionedId:"neonkube/operator-sdk/best-practices",id:"neonkube/operator-sdk/best-practices",title:"Best Practices",description:"Best practices to follow when building Operators.",source:"@site/docs/neonkube/operator-sdk/best-practices.mdx",sourceDirName:"neonkube/operator-sdk",slug:"/neonkube/operator-sdk/best-practices",permalink:"/docs/neonkube/operator-sdk/best-practices",draft:!1,editUrl:"https://github.com/nforgeio/documentation/edit/master/docs/neonkube/operator-sdk/best-practices.mdx",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7,displayed_sidebar:"neonkube",title:"Best Practices",hide_title:!1,hide_table_of_contents:!1,description:"Best practices to follow when building Operators.",keywords:["neonkube kubernetes operator sdk resource controllers"],last_update:{author:"Marcus Bowyer"}},sidebar:"neonkube",previous:{title:"Monitoring",permalink:"/docs/neonkube/operator-sdk/monitoring"}},c={},l=[{value:"Implementing a Reconciler",id:"implementing-a-reconciler",level:2},{value:"Idempotency",id:"idempotency",level:3},{value:"Reconcile All Resources All the Time",id:"reconcile-all-resources-all-the-time",level:3},{value:"Owner References",id:"owner-references",level:3}],p={toc:l},d="wrapper";function u(e){let{components:t,...n}=e;return(0,o.kt)(d,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"best-practices"},"Best Practices"),(0,o.kt)("h2",{id:"implementing-a-reconciler"},"Implementing a Reconciler"),(0,o.kt)("h3",{id:"idempotency"},"Idempotency"),(0,o.kt)("p",null,"Reconcile is called for every event received from the Controller, which could be multiple times for the same resource. This includes listing all resources\nthe first time the Operator starts or restarts. It is important that reconciliation is ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Idempotence"},"idempotent"),"."),(0,o.kt)("p",null,"A function is said to be idempotent if it can be applied multiple times without changing the result beyond the initial application."),(0,o.kt)("h3",{id:"reconcile-all-resources-all-the-time"},"Reconcile All Resources All the Time"),(0,o.kt)("p",null,"Reconciliation can be triggered from many different event sources. It could be tempting to check the event to try to figure out what needs reconciling, but this is considered\nto be an anti-pattern for Operators. Because of the distributed nature of Kubernetes, it's possible that the Operator did not receive all events and in this situation making\nassumptions about the current state could be dangerous. For this reason it is best practice to reconcile all resources all the time."),(0,o.kt)("h3",{id:"owner-references"},"Owner References"),(0,o.kt)("p",null,"Dependent objects created by the Reconciler should have an Owner Reference that references their owner resource.\nThis will allow Kubernetes to clean up resources when the parent resource is deleted."),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Cross-namespace owner references are disallowed by design. Namespaced dependents can specify cluster-scoped or namespaced owners. A namespaced owner must exist in\nthe same namespace as the dependent. If it does not, the owner reference is treated as absent, and the dependent is subject to deletion once all owners are verified absent."),(0,o.kt)("p",{parentName:"admonition"},"Cluster-scoped dependents can only specify cluster-scoped owners. In v1.20+, if a cluster-scoped dependent specifies a namespaced kind as an owner, it is treated as\nhaving an unresolvable owner reference, and is not able to be garbage collected."),(0,o.kt)("p",{parentName:"admonition"},"For cross-namespace garbage collection, use a ",(0,o.kt)("a",{parentName:"p",href:"./finalizers"},(0,o.kt)("inlineCode",{parentName:"a"},"Finalizer")),".")),(0,o.kt)("p",null,"Owner references can be created by calling the ",(0,o.kt)("inlineCode",{parentName:"p"},"MakeOwnerReference()")," extension method on any resource."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"var pod = new V1Pod().Initialize()\npod.AddOwnerReference(resource.MakeOwnerReference());\n")))}u.isMDXComponent=!0}}]);