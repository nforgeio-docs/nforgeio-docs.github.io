[{"title":"Intro","type":0,"sectionRef":"#","url":"/docs/intro","content":"Intro","keywords":"neonforge"},{"title":"Installation","type":0,"sectionRef":"#","url":"/docs/neonkube/getting-started/installation","content":"","keywords":"neon-desktop neonkube"},{"title":"Requirements​","type":1,"pageTitle":"Installation","url":"/docs/neonkube/getting-started/installation#requirements","content":""},{"title":"Operating System​","type":1,"pageTitle":"Installation","url":"/docs/neonkube/getting-started/installation#operating-system","content":"Windows HomeWindows Professional Future: MacOSLinux "},{"title":"Hardware​","type":1,"pageTitle":"Installation","url":"/docs/neonkube/getting-started/installation#hardware","content":"RAM: 16GB Virtual Machine has 8GBNeonKube consumes ~5.5 GB CPU: 4Disk: 64GB "},{"title":"Windows​","type":1,"pageTitle":"Installation","url":"/docs/neonkube/getting-started/installation#windows","content":"Installing NeonKUBE on windows goes here "},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/neonkube","content":"Introduction NeonKUBE is a Full Stack Kubernetes Distribution which includes Kubernetes Core, opensource and custom add-ons, as well as a other tools like neon-desktop and neon-cli. Not only can NeonKUBE clusters be deployed directly on local servers or the cloud, you can also deploy full stack clusters on a laptop or workstation. NeonKUBE requires a 4-core computer with at least 16 GiB RAM and about 75 GiB of free disk space when deploying a local cluster. The local cluster runs on a Hyper-V virtual machine with 8 GiB RAM and currently Kubernetes and NeonKUBE are consuming about 5.5 gig of memory, leaving 2.5 gig for user applications. NeonKUBE clusters can be suspended at any time to quickly release this memory when the cluster isn’t needed. This only takes a few seconds.","keywords":"neonkube"},{"title":"Hello World Example","type":0,"sectionRef":"#","url":"/docs/neonkube/how-to-guides/hello-world","content":"Hello World Example This tutorial demonstrates how to deploy a simple application to a NeonKUBE cluster. Clone demo repository​ git clone https://github.com/nforgeio/neonKUBE-demos.git set DEMO_DIR=C:\\&lt;CURRENT-DIRECTORY&gt;\\neonKUBE-demos set CLUSTER_ID=&lt;YOUR_CLUSTER_ID&gt; Build Hello World image​ In this step, we build the hello-world container image and publish it to the local cluster registry. cd %DEMO_DIR%\\Services\\hello-world dotnet publish hello-world.csproj -c Release -o .\\bin\\Release\\net6.0\\publish unix-text docker-entrypoint.sh docker build -t neon-registry.%CLUSTER_ID%.neoncluster.io/library/hello-world . docker push neon-registry.%CLUSTER_ID%.neoncluster.io/library/hello-world Deploy hello World​ Here we are creating a Kubernetes Deployment from the yaml manifest. cd %DEMO_DIR% cp helloworld.yaml &quot;%TEMP%\\helloworld.yaml&quot; neon-build replace &quot;%TEMP%\\helloworld.yaml&quot; &quot;$&lt;CLUSTER_ID&gt;&quot; %CLUSTER_ID% neon apply -f &quot;%TEMP%\\helloworld.yaml&quot; rm &quot;%TEMP%\\helloworld.yaml&quot; Hello World can now be accessed at https://hello-world.CLUSTER-ID.neoncluster.io. Replace CLUSTER-ID with your cluster ID.","keywords":"neonkube"},{"title":"Resource Finalizers","type":0,"sectionRef":"#","url":"/docs/neonkube/operator-sdk/finalizers","content":"","keywords":"neonkube kubernetes operator sdk resource finalizers"},{"title":"Introduction​","type":1,"pageTitle":"Resource Finalizers","url":"/docs/neonkube/operator-sdk/finalizers#introduction","content":"Finalizers are namespaced keys that tell Kubernetes to wait until specific conditions are met before it fully deletes resources marked for deletion. When you tell Kubernetes to delete an object that has finalizers specified for it, the Kubernetes API will mark the object for deletion. The object will only be deleted once the finalizers have run successfully. Finalizers can be used for garbage collection of resources. For example, you can define a finalizer to clean up any related resources before deleting the target resource. Finalizers can also be used to prevent accidental deletion of resources. "},{"title":"Example​","type":1,"pageTitle":"Resource Finalizers","url":"/docs/neonkube/operator-sdk/finalizers#example","content":"public class ExampleFinalizer : IResourceFinalizer&lt;V1ExampleEntity&gt; { private ILogger logger; public ExampleFinalizer(ILogger logger) { this.logger = logger; } public async Task FinalizeAsync(V1ExampleEntity resource) { logger.LogInformation($&quot;FINALIZED: {resource.Name()}&quot;); } }  "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/docs/neonkube/operator-sdk/getting-started","content":"","keywords":"neonkube kubernetes operator sdk getting started"},{"title":"Installation​","type":1,"pageTitle":"Getting Started","url":"/docs/neonkube/operator-sdk/getting-started#installation","content":"dotnet add package Neon.Kube.Operator  "},{"title":"How to use​","type":1,"pageTitle":"Getting Started","url":"/docs/neonkube/operator-sdk/getting-started#how-to-use","content":""},{"title":"Startup.cs​","type":1,"pageTitle":"Getting Started","url":"/docs/neonkube/operator-sdk/getting-started#startupcs","content":"public void ConfigureServices(IServiceCollection services) { services.AddKubernetesOperator(); } public void Configure(IApplicationBuilder app) { app.UseKubernetesOperator(); }  By default, all Controllers, Finalizers and Webhooks in your assembly will be added to the operator. "},{"title":"Resource Controllers","type":0,"sectionRef":"#","url":"/docs/neonkube/operator-sdk/controllers","content":"","keywords":"neonkube kubernetes operator sdk resource controllers"},{"title":"Introduction​","type":1,"pageTitle":"Resource Controllers","url":"/docs/neonkube/operator-sdk/controllers#introduction","content":"Resource controllers are responsible for bringing the actual state of a resource to the desired state, which is expressed in the Custom Resource object specification. As users update the desired state of the resource, the Controller "},{"title":"Example​","type":1,"pageTitle":"Resource Controllers","url":"/docs/neonkube/operator-sdk/controllers#example","content":"public class ExampleController : IResourceController&lt;V1ExampleEntity&gt; { private ILogger logger; public ExampleController(ILogger logger) { this.logger = logger; } public static async Task StartAsync(IServiceProvider serviceProvider) { // Runs only once at startup. Use this to configure your operator if needed. logger.LogInformation($&quot;RECONCILED: {resource.Name()}&quot;); } public Task&lt;ResourceControllerResult&gt; ReconcileAsync(V1ExampleEntity resource) { logger.LogInformation($&quot;RECONCILED: {resource.Name()}&quot;); return ResourceControllerResult.Ok(); } public async Task StatusModifiedAsync(V1ExampleEntity resource) { logger.LogInformation($&quot;STATUS MODIFIED: {resource.Name()}&quot;); } public async Task DeletedAsync(V1ExampleEntity resource) { logger.LogInformation($&quot;DELETED: {resource.Name()}&quot;); } }  "},{"title":"Requeuing​","type":1,"pageTitle":"Resource Controllers","url":"/docs/neonkube/operator-sdk/controllers#requeuing","content":"If a function throws an error, the event will be requeued. You can configure requeue settings in two ways. "},{"title":"Global defaults​","type":1,"pageTitle":"Resource Controllers","url":"/docs/neonkube/operator-sdk/controllers#global-defaults","content":"services.AddKubernetesOperator(settings =&gt; { settings.ResourceManagerOptions = new ResourceManagerOptions() { ErrorMinRequeueInterval = TimeSpan.FromSeconds(1), ErrorMaxRequeueInterval = TimeSpan.FromSeconds(1), ErrorMaxRetryCount = 10, }; })  "},{"title":"Per controller​","type":1,"pageTitle":"Resource Controllers","url":"/docs/neonkube/operator-sdk/controllers#per-controller","content":"services.AddKubernetesOperator(options =&gt; { options.AssemblyScanningEnabled = false; }) .AddController&lt;ExampleController&gt;(options: new ResourceManagerOptions() { ErrorMinRequeueInterval = TimeSpan.FromSeconds(1), ErrorMaxRequeueInterval = TimeSpan.FromSeconds(1), ErrorMaxRetryCount = 10, })  "},{"title":"Manual​","type":1,"pageTitle":"Resource Controllers","url":"/docs/neonkube/operator-sdk/controllers#manual","content":"public Task&lt;ResourceControllerResult&gt; ReconcileAsync(V1ExampleEntity resource) { logger.LogInformation($&quot;RECONCILED: {resource.Name()}&quot;); return ResourceControllerResult.RequeueEvent(TimeSpan.FromSeconds(10)); }  "},{"title":"Leader election​","type":1,"pageTitle":"Resource Controllers","url":"/docs/neonkube/operator-sdk/controllers#leader-election","content":"The following methods are provided for reacting to leadership events. public async Task OnPromotionAsync() { logger.LogInformation($&quot;PROMOTED&quot;); } public async Task OnDemotionAsync() { logger.LogInformation($&quot;DEMOTED&quot;); } public async Task OnNewLeaderAsyncc(string identity) { logger.LogInformation($&quot;NEW LEADER: {identity}&quot;); }  "},{"title":"Filtering​","type":1,"pageTitle":"Resource Controllers","url":"/docs/neonkube/operator-sdk/controllers#filtering","content":"To filter out resources, add the optional Filter method to the controller. public bool Filter(V1Secret resource) { return (resource.Name() == &quot;foo&quot;); }  "},{"title":"Validating Webhooks","type":0,"sectionRef":"#","url":"/docs/neonkube/operator-sdk/validating-webhooks","content":"","keywords":"neonkube kubernetes operator sdk resource validating webhooks"},{"title":"Introduction​","type":1,"pageTitle":"Validating Webhooks","url":"/docs/neonkube/operator-sdk/validating-webhooks#introduction","content":"Validating webhooks can be used to perform validations that go beyond the capabilities of OpenAPI schema validation. A validating Webhook can reject the request, but it cannot modify the object received in the request. "},{"title":"Example​","type":1,"pageTitle":"Validating Webhooks","url":"/docs/neonkube/operator-sdk/validating-webhooks#example","content":"[Webhook( name: &quot;pod-policy.neonkube.io&quot;, serviceName: &quot;example-operator&quot;, @namespace: &quot;default&quot;, admissionReviewVersions: &quot;v1&quot;, failurePolicy: &quot;Ignore&quot;)] [WebhookRule( apiGroups: V1Pod.KubeGroup, apiVersions: V1Pod.KubeApiVersion, operations: AdmissionOperations.Create | AdmissionOperations.Update, resources: V1Pod.KubePluralName, scope: &quot;*&quot;)] public class PodWebhook : IValidatingWebhook&lt;V1Pod&gt; { private Ilogger logger { get; set; } public PodWebhook(Ilogger logger) : base() { this.logger = logger; } public async Task&lt;ValidationResult&gt; CreateAsync(V1Pod entity, bool dryRun) { if (entity.Metadata.Name == &quot;invalid-entity&quot;) { logger.LogInformation($&quot;Entity name is not valid. [{entity.Namespace()}/{entity.Name()}]&quot;); return ValidationResult.Fail(statusCode: 500, statusMessage: &quot;Entity name is not valid.&quot;); } return ValidationResult.Success(); } public async Task&lt;ValidationResult&gt; UpdateAsync(V1Pod entity, V1Pod oldEntity, bool dryRun) { if (entity.Metadata.Name == &quot;invalid-entity&quot;) { logger.LogInformation($&quot;Entity name is not valid. [{entity.Namespace()}/{entity.Name()}]&quot;); return ValidationResult.Fail(statusCode: 500, statusMessage: &quot;Entity name is not valid.&quot;); } return ValidationResult.Success(); }  "},{"title":"Intro","type":0,"sectionRef":"#","url":"/docs/neonsdk","content":"Intro NeonSDK is an open source project released under the Apache 2.0 license. This project includes several class general purpose libraries published as nuget packages (known as the Neon libraries).","keywords":"neonsdk"},{"title":"Mutating Webhooks","type":0,"sectionRef":"#","url":"/docs/neonkube/operator-sdk/mutating-webhooks","content":"","keywords":"neonkube kubernetes operator sdk resource mutating webhooks"},{"title":"Introduction​","type":1,"pageTitle":"Mutating Webhooks","url":"/docs/neonkube/operator-sdk/mutating-webhooks#introduction","content":"Mutating webhooks are most frequently used for setting default values. They can modify objects by creating a patch that will be sent back in the admission response. "},{"title":"Example Mutating Webhook​","type":1,"pageTitle":"Mutating Webhooks","url":"/docs/neonkube/operator-sdk/mutating-webhooks#example-mutating-webhook","content":"[Webhook( name: &quot;pod-policy.neonkube.io&quot;, serviceName: &quot;example-operator&quot;, @namespace: &quot;default&quot;, admissionReviewVersions: &quot;v1&quot;, failurePolicy: &quot;Ignore&quot;)] [WebhookRule( apiGroups: V1Pod.KubeGroup, apiVersions: V1Pod.KubeApiVersion, operations: AdmissionOperations.Create | AdmissionOperations.Update, resources: V1Pod.KubePluralName, scope: &quot;*&quot;)] public class PodWebhook : IMutatingWebhook&lt;V1Pod&gt; { private Ilogger logger { get; set; } private bool modified = false; public PodWebhook(Ilogger logger) : base() { this.logger = logger; } public async Task&lt;MutationResult&gt; CreateAsync(V1Pod entity, bool dryRun) { logger.LogInformation($&quot;Received create request for pod {entity.Namespace()}/{entity.Name()}&quot;); if (modified) { return await Task.FromResult(MutationResult.Modified(entity)); } return await Task.FromResult(MutationResult.NoChanges()); } public async Task&lt;MutationResult&gt; UpdateAsync(V1Pod entity, V1Pod oldEntity, bool dryRun) { logger.LogInformation($&quot;Received update request for pod {entity.Namespace()}/{entity.Name()}&quot;); if (modified) { return await Task.FromResult(MutationResult.Modified(entity)); } return await Task.FromResult(MutationResult.NoChanges()); }  "},{"title":"Neon CLI Reference","type":0,"sectionRef":"#","url":"/docs/references/neon-cli","content":"Neon CLI Reference","keywords":"neonkube"}]