[{"title":"Getting Started","type":0,"sectionRef":"#","url":"/docs/installation","content":"Getting Started To use NeonKUBE, you will need to installNeonDESKTOP, a desktop application that provides a graphical user interface for NeonKUBE. With NeonDESKTOP, you can easily deploy and manage NeonKUBE clusters on your preferred platform, such as AWS, Azure, Hyper-V, or XenServer. Once you have NeonDESKTOP installed, go ahead and check out the instructions for deploying NeonKUBE on your preferred platform. NeonDESKTOP - NeonDESKTOP is a full NeonKUBE cluster running on your desktop machine.Azure - How to deploy a cluster to Azure.XenServer - How to deploy a cluster to XenServer.","keywords":"neon  neonforge  neonkube  neondesktop  neon-desktop  neon-cli  kubernetes  documentation"},{"title":"Intro","type":0,"sectionRef":"#","url":"/docs/intro","content":"Intro","keywords":"introduction"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/neonkube","content":"Introduction NeonKUBE is a full-stack, production-ready Kubernetes distribution that aims to provide a seamless and consistent developer experience across different environments. Whether you want to run your applications on your laptop, on-premise servers, or on the cloud, neonKUBE can help you deploy and manage them with ease. With NeonKUBE, you can enjoy the following benefits: Simplicity: You don't have to worry about installing and configuring dozens of different tools and components. You can simply use neon-cli or neon-desktop to create a cluster with a single command or click.Consistency: You don't have to deal with different versions or configurations of Kubernetes or its add-ons across different environments or platforms. You can use the same NeonKUBE distribution everywhere.Reliability: You don't have to worry about compatibility issues or bugs caused by mismatched components or dependencies. You can rely on NeonKUBE's tested and stable components.Productivity: You don't have to waste time on tedious tasks like setting up VPNs or SSH tunnels. You can use neon-desktop's intuitive interface or neon-cli's powerful commands to access and manage your cluster easily.","keywords":"introduction"},{"title":"Hello World Example","type":0,"sectionRef":"#","url":"/docs/neonkube/how-to-guides/hello-world","content":"","keywords":"helloworld example howto"},{"title":"Clone demo repository​","type":1,"pageTitle":"Hello World Example","url":"/docs/neonkube/how-to-guides/hello-world#clone-demo-repository","content":"git clone https://github.com/nforgeio/neonKUBE-demos.git  "},{"title":"Publish images​","type":1,"pageTitle":"Hello World Example","url":"/docs/neonkube/how-to-guides/hello-world#publish-images","content":"NeonKUBE Clusters include a built-in container registry to store images for deployment. In this step we'll publish the necessary container images to the Cluster Registry. note You can optionally build the containers yourself, rather than using the public images. To do this, add the -build flag to the following command. You'll need to have Visual Studio and the .NET SDK installed to do this. powershell -f publish.ps1  "},{"title":"Deploy hello-world-operator​","type":1,"pageTitle":"Hello World Example","url":"/docs/neonkube/how-to-guides/hello-world#deploy-hello-world-operator","content":"neon apply -f hello-world-operator.yaml  "},{"title":"Deploy hello-world​","type":1,"pageTitle":"Hello World Example","url":"/docs/neonkube/how-to-guides/hello-world#deploy-hello-world","content":"You can edit the hello-world.yaml spec to change the deployment behaviour. apiVersion: demo.neonkube.io/v1alpha1 kind: HelloWorldDemo metadata: name: hello-world labels: app: hello-world spec: logLevel: debug helloWorldReplicas: 2 loadGeneratorReplicas: 3 storageType: ephemeral # ephemeral or nfs ssoEnabled: false neonDashboardEnabled: false  neon apply -f hello-world.yaml  "},{"title":"View Hello, World!​","type":1,"pageTitle":"Hello World Example","url":"/docs/neonkube/how-to-guides/hello-world#view-hello-world","content":"HTTPS! Every NeonKUBE Cluster comes with an SSL certificate to make it easy to deploy new services. The Hello World demo is deployed using this certificate. neonDESKTOPneonKUBE Open: https://hello-world.desktop.neoncluster.io. "},{"title":"HelloWorldDemo Options​","type":1,"pageTitle":"Hello World Example","url":"/docs/neonkube/how-to-guides/hello-world#helloworlddemo-options","content":"The HelloWorldDemo Custom Resource spec allows for configuration of the demo. These options can be changed at any time by modifying thehello-world.yaml manifest and applying the changes withneon apply -f hello-world.yaml. "},{"title":"logLevel​","type":1,"pageTitle":"Hello World Example","url":"/docs/neonkube/how-to-guides/hello-world#loglevel","content":"logLevel can be set to the following: CRITICALERRORWARNINGINFORMATIONDEBUGTRACE "},{"title":"helloWorldReplicas​","type":1,"pageTitle":"Hello World Example","url":"/docs/neonkube/how-to-guides/hello-world#helloworldreplicas","content":"This is the number of replicas that will be deployed for the hello-world web app. "},{"title":"loadGeneratorReplicas​","type":1,"pageTitle":"Hello World Example","url":"/docs/neonkube/how-to-guides/hello-world#loadgeneratorreplicas","content":"This is the number of replicas for the load generator app. Increase this to generate more load. "},{"title":"storageType​","type":1,"pageTitle":"Hello World Example","url":"/docs/neonkube/how-to-guides/hello-world#storagetype","content":"storageType can be set to ephemeral or nfs. The hello-world app has a /storage page where users can update a text file. This can be used to verify the behaviours described below. Try updating the text file and killing some pods with the &quot;Kill Pods&quot; button to see what happens. ephemeral does not create any KubernetesPersistent Volumes. Each pod has its own ephemeral volume, and any data stored on it will be lost when the pod is deleted.nfs Creates a persistent volume that is shared between all hello-worldpods as describedhere. In this mode, any data stored on the Volume will be persisted. "},{"title":"ssoEnabled​","type":1,"pageTitle":"Hello World Example","url":"/docs/neonkube/how-to-guides/hello-world#ssoenabled","content":"If set to true, the Operator will configure the hello-world demo to use Neon Single Sign On. Users will need cluster credentials to access the demo. "},{"title":"neonDashboardEnabled​","type":1,"pageTitle":"Hello World Example","url":"/docs/neonkube/how-to-guides/hello-world#neondashboardenabled","content":"If set to true, the Operator will add a link to the hello-world dashboard to the NeonKUBE dashboard. "},{"title":"Deploy An Azure Cluster","type":0,"sectionRef":"#","url":"/docs/neonkube/installation/azure","content":"","keywords":"azure"},{"title":"Prerquisites​","type":1,"pageTitle":"Deploy An Azure Cluster","url":"/docs/neonkube/installation/azure#prerquisites","content":"Make sure you have neon-desktop installed. To install, follow the neon-desktop installation instructions here "},{"title":"Creating a cluster​","type":1,"pageTitle":"Deploy An Azure Cluster","url":"/docs/neonkube/installation/azure#creating-a-cluster","content":""},{"title":"Azure CLI​","type":1,"pageTitle":"Deploy An Azure Cluster","url":"/docs/neonkube/installation/azure#azure-cli","content":"Install theAzure CLI. "},{"title":"Azure RBAC​","type":1,"pageTitle":"Deploy An Azure Cluster","url":"/docs/neonkube/installation/azure#azure-rbac","content":"Run the following command: az ad sp create-for-rbac --name USER --role owner --scopes /subscriptions/AZURE_SUBSCRIPTION_ID  The output will be something like: { &quot;appId&quot;: &quot;AZURE_CLIENT_ID&quot;, &quot;displayName&quot;: &quot;example-app-name&quot;, &quot;name&quot;: &quot;http://example-app-name&quot;, &quot;password&quot;: &quot;AZURE_CLIENT_SECRET&quot;, &quot;tenant&quot;: &quot;AZURE_TENANT_ID&quot; }  "},{"title":"Cluster Definition​","type":1,"pageTitle":"Deploy An Azure Cluster","url":"/docs/neonkube/installation/azure#cluster-definition","content":"Create aCluster Definitionthat describes the cluster. Warning Make sure that the Azure account has enoughResource Quotato deploy the cluster. Be sure to substitute the following from the previous steps: AZURE_SUBSCRIPTION_IDAZURE_TENANT_IDAZURE_CLIENT_IDAZURE_CLIENT_SECRET name: azure-tiny datacenter: westus2 purpose: development timeSources: - pool.ntp.org kubernetes: allowPodsOnControlPlane: true storage: hosting: environment: azure cloud: prefixResourceNames: default azure: subscriptionId: AZURE_SUBSCRIPTION_ID tenantId: AZURE_TENANT_ID clientId: AZURE_CLIENT_ID clientSecret: AZURE_CLIENT_SECRET region: westus2 disableProximityPlacement: false defaultVmSize: Standard_E4vs_v5 nodes: control-0: role: control-plane  Save the Cluster Definition. "},{"title":"Creating the Cluster​","type":1,"pageTitle":"Deploy An Azure Cluster","url":"/docs/neonkube/installation/azure#creating-the-cluster","content":"Right click the neon-desktop icon in the taskbar &gt; Deploy cluster When the dialog pops up, select the Cluster Definition file you saved earlier.Grab a coffee and wait for neon-desktop to create the cluster. "},{"title":"Deploy A Neon Desktop Cluster","type":0,"sectionRef":"#","url":"/docs/neonkube/installation/neon-desktop-cluster","content":"","keywords":"install cluster"},{"title":"Prerquisites​","type":1,"pageTitle":"Deploy A Neon Desktop Cluster","url":"/docs/neonkube/installation/neon-desktop-cluster#prerquisites","content":"Make sure you have neon-desktop installed. To install, follow the neon-desktop installation instructions here "},{"title":"Creating a cluster​","type":1,"pageTitle":"Deploy A Neon Desktop Cluster","url":"/docs/neonkube/installation/neon-desktop-cluster#creating-a-cluster","content":"Right click the neon-desktop icon in the taskbar &gt; Deploy built in cluster Select Install as Hyper-V Virtual Machine and click Next Grab a coffee and wait for neon-desktop to create the cluster.Once the cluster is installed, navigate to the neon-desktopdashboard "},{"title":"Installation","type":0,"sectionRef":"#","url":"/docs/neonkube/installation/neon-desktop","content":"","keywords":"install cluster"},{"title":"Requirements​","type":1,"pageTitle":"Installation","url":"/docs/neonkube/installation/neon-desktop#requirements","content":""},{"title":"Operating System​","type":1,"pageTitle":"Installation","url":"/docs/neonkube/installation/neon-desktop#operating-system","content":"Windows HomeWindows Professional Future: MacOSLinux "},{"title":"Hardware​","type":1,"pageTitle":"Installation","url":"/docs/neonkube/installation/neon-desktop#hardware","content":"RAM: 16GB Virtual Machine has 8GBNeonKube consumes ~5.5 GB CPU: 4Disk: 64GB "},{"title":"Installing​","type":1,"pageTitle":"Installation","url":"/docs/neonkube/installation/neon-desktop#installing","content":"WindowsMacOS Download the installer from here.Navigate to the directory where you downloaded the installer to and run the installer.Follow the prompts on the neon-desktop installer to proceed.If Hyper-V was not enabled before installation. You must restart before creating a cluster. "},{"title":"Uninstalling​","type":1,"pageTitle":"Installation","url":"/docs/neonkube/installation/neon-desktop#uninstalling","content":"WindowsMacOS From the taskbar, click the Start menu.Go to Settings &gt; Apps &gt; Installed Apps.Find and select Neon Desktop.Click the three dots &gt; Uninstall and click it again when the confirmation appears.Follow the prompts on the neon-desktop uninstaller to proceed.Click Finish when complete. "},{"title":"Deploy An XenServer/XCP-ng Cluster","type":0,"sectionRef":"#","url":"/docs/neonkube/installation/xenserver","content":"","keywords":"XenServer XCP XCP-ng"},{"title":"Prerquisites​","type":1,"pageTitle":"Deploy An XenServer/XCP-ng Cluster","url":"/docs/neonkube/installation/xenserver#prerquisites","content":"Make sure you have neon-desktop installed. To install, follow the neon-desktop installation instructions here "},{"title":"Creating a cluster​","type":1,"pageTitle":"Deploy An XenServer/XCP-ng Cluster","url":"/docs/neonkube/installation/xenserver#creating-a-cluster","content":""},{"title":"Cluster Definition​","type":1,"pageTitle":"Deploy An XenServer/XCP-ng Cluster","url":"/docs/neonkube/installation/xenserver#cluster-definition","content":"Create aCluster Definitionthat describes the cluster. Be sure to substitute the following: XEN_HOST_USERNAME - the Xen/XCP host username.XEN_HOST_PASSWORD - the Xen/XCP host password. name: xcp-tiny datacenter: wrt-00 purpose: development timeSources: - pool.ntp.org kubernetes: allowPodsOnControlPlane: true hosting: environment: xenserver vm: hostUsername: XEN_HOST_USERNAME hostPassword: XEN_HOST_PASSWORD namePrefix: vm_prefix hosts: - name: WRT-00-XEN-00 address: 10.100.128.1 xenServer: snapshot: true network: nameservers: - 8.8.8.8 - 8.8.4.4 gateway: 10.100.0.1 premiseSubnet: 10.100.0.0/16 nodes: control-0: role: control-plane address: 10.100.10.1 vm: host: WRT-00-XEN-00 cores: 4 memory: 8GiB osDisk: 64GiB  Save the Cluster Definition. "},{"title":"Creating the Cluster​","type":1,"pageTitle":"Deploy An XenServer/XCP-ng Cluster","url":"/docs/neonkube/installation/xenserver#creating-the-cluster","content":"Right click the neon-desktop icon in the taskbar &gt; Deploy cluster When the dialog pops up, select the Cluster Definition file you saved earlier.Grab a coffee and wait for neon-desktop to create the cluster. "},{"title":"Networking","type":0,"sectionRef":"#","url":"/docs/neonkube/networking","content":"","keywords":"networking"},{"title":"Istio​","type":1,"pageTitle":"Networking","url":"/docs/neonkube/networking#istio","content":"Istio is an open source service mesh that provides a uniform way to connect, secure, control and observe services running on Kubernetes clusters. By using Istio on neonKUBE clusters, developers can benefit from advanced features such as traffic management, security policies, telemetry and observability. "},{"title":"Ingress​","type":1,"pageTitle":"Networking","url":"/docs/neonkube/networking#ingress","content":"Ingress can be configured by creating Gateway and VirtualService resources. All NeonKUBE clusters are configured with a secure Gateway by default to allow users to get up and running quickly without having to manage DNS and certificates. Here is an example VirtualService that uses the default neoncluster-gateway. apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: example namespace: default spec: gateways: - neon-ingress/neoncluster-gateway hosts: - example.CLUSTER_ID.neoncluster.io http: - match: - uri: prefix: / route: - destination: host: example.default.svc.cluster.local port: number: 80  "},{"title":"Security","type":0,"sectionRef":"#","url":"/docs/neonkube/security","content":"Security The neon-cluster-operator is a service that runs in every NeonKUBE cluster. It is responsible for managing the lifecycle of the cluster, including certificate rotation and security updates. Certificate rotation is the process of periodically generating new cryptographic keys and certificates for the cluster components, such as the API server, the etcd database, and the kubelet agents. This ensures that the communication between these components is secure and authenticated, and that any compromised or expired certificates are replaced. Security updates are patches or fixes that address vulnerabilities or bugs in the cluster software or operating system. The neon-cluster-operator monitors for available security updates and applies them to all nodes in the cluster automatically or on demand. This ensures that the cluster is protected from potential attacks and runs smoothly and reliably.","keywords":"security"},{"title":"Intro","type":0,"sectionRef":"#","url":"/docs/neonsdk","content":"Intro NeonSDK is an open source project released under the Apache 2.0 license. This project includes several class general purpose libraries published as nuget packages (known as the Neon libraries).","keywords":"neonsdk"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/operator-sdk","content":"Introduction NeonKUBE is a Full Stack Kubernetes Distribution which includes Kubernetes Core, opensource and custom add-ons, as well as a other tools like neon-desktop and neon-cli. Not only can NeonKUBE clusters be deployed directly on local servers or the cloud, you can also deploy full stack clusters on a laptop or workstation. NeonKUBE requires a 4-core computer with at least 16 GiB RAM and about 75 GiB of free disk space when deploying a local cluster. The local cluster runs on a Hyper-V virtual machine with 8 GiB RAM and currently Kubernetes and NeonKUBE are consuming about 5.5 gig of memory, leaving 2.5 gig for user applications. NeonKUBE clusters can be suspended at any time to quickly release this memory when the cluster isn’t needed. This only takes a few seconds.","keywords":"introduction"},{"title":"Best Practices","type":0,"sectionRef":"#","url":"/docs/operator-sdk/best-practices","content":"","keywords":"operator sdk crd crds custom resource resource controller"},{"title":"Implementing a Reconciler​","type":1,"pageTitle":"Best Practices","url":"/docs/operator-sdk/best-practices#implementing-a-reconciler","content":""},{"title":"Idempotency​","type":1,"pageTitle":"Best Practices","url":"/docs/operator-sdk/best-practices#idempotency","content":"Reconcile is called for every event received from the Controller, which could be multiple times for the same resource. This includes listing all resources the first time the Operator starts or restarts. It is important that reconciliation is idempotent. A function is said to be idempotent if it can be applied multiple times without changing the result beyond the initial application. "},{"title":"Reconcile All Resources All the Time​","type":1,"pageTitle":"Best Practices","url":"/docs/operator-sdk/best-practices#reconcile-all-resources-all-the-time","content":"Reconciliation can be triggered from many different event sources. It could be tempting to check the event to try to figure out what needs reconciling, but this is considered to be an anti-pattern for Operators. Because of the distributed nature of Kubernetes, it's possible that the Operator did not receive all events and in this situation making assumptions about the current state could be dangerous. For this reason it is best practice to reconcile all resources all the time. "},{"title":"Owner References​","type":1,"pageTitle":"Best Practices","url":"/docs/operator-sdk/best-practices#owner-references","content":"Dependent objects created by the Reconciler should have an Owner Reference that references their owner resource. This will allow Kubernetes to clean up resources when the parent resource is deleted. info Cross-namespace owner references are disallowed by design. Namespaced dependents can specify cluster-scoped or namespaced owners. A namespaced owner must exist in the same namespace as the dependent. If it does not, the owner reference is treated as absent, and the dependent is subject to deletion once all owners are verified absent. Cluster-scoped dependents can only specify cluster-scoped owners. In v1.20+, if a cluster-scoped dependent specifies a namespaced kind as an owner, it is treated as having an unresolvable owner reference, and is not able to be garbage collected. For cross-namespace garbage collection, use a Finalizer. Owner references can be created by calling the MakeOwnerReference() extension method on any resource. var pod = new V1Pod().Initialize() pod.AddOwnerReference(resource.MakeOwnerReference());  "},{"title":"Volumes and Storage","type":0,"sectionRef":"#","url":"/docs/neonkube/volumes-storage","content":"","keywords":"persistentvolume persistentvolumeclaim storage volumes persistence"},{"title":"Persistence Types​","type":1,"pageTitle":"Volumes and Storage","url":"/docs/neonkube/volumes-storage#persistence-types","content":"neonKUBE provides multiple persistence types for different applications. "},{"title":"Network File System​","type":1,"pageTitle":"Volumes and Storage","url":"/docs/neonkube/volumes-storage#network-file-system","content":"The most commonly used storage type is Network File System (NFS). NFS supportsReadWriteMany and can be used for small applications requiring shared access to files. note NFS is relatively slow and is not a good option for complex applications requiring fast operations. PVCNFSDeploymentpodpodpod "},{"title":"Block Storage​","type":1,"pageTitle":"Volumes and Storage","url":"/docs/neonkube/volumes-storage#block-storage","content":"Block Storage volumes are dynamically provisioned storage volumes. Using this mode, each pod in the application will have a separate Persistent Volume. PVCPVCPVCStatefulSetpodpodpod There are different block storage engines and they each have different strengths outlined here: OpenEBS cStor​ cStor is the most commonly used and provides enterprise grade features such as synchronous data replication, snapshots, clones, thin provisioning of data, high resiliency of data, data consistency and on-demand increase of capacity or performance. OpenEBS Jiva​ Jiva is a lightweight distributed storage engine. It is not as performant as cStor but is great for use on smaller clusters. OpenEBS LocalPV​ LocalPV provides dynamic provisioning ofKubernetes Local Volumes. This is great for applications that require the best performance and can tolerate reducad availability. A good use case for LocalPV is a distributed database. "},{"title":"Object Storage​","type":1,"pageTitle":"Volumes and Storage","url":"/docs/neonkube/volumes-storage#object-storage","content":"NeonKUBE provides Minio which provides high-performance, S3 compatible object storage. NeonKUBE also provides aMinio Bucketcustom resource for easily managing buckets. bucket.yaml​ apiVersion: minio.neonkube.io/v1alpha1 kind: MinioBucket metadata: name: my-minio-bucket namespace: default spec: objectLocking: false region: us-west-2 tenant: minio versioning: &quot;Off&quot;  "},{"title":"Resource Finalizers","type":0,"sectionRef":"#","url":"/docs/operator-sdk/finalizers","content":"","keywords":"operator sdk crd crds custom resource resource finalizer finalizer"},{"title":"Introduction​","type":1,"pageTitle":"Resource Finalizers","url":"/docs/operator-sdk/finalizers#introduction","content":"Finalizers are namespaced keys that tell Kubernetes to wait until specific conditions are met before it fully deletes resources marked for deletion. When you tell Kubernetes to delete an object that has finalizers specified for it, the Kubernetes API will mark the object for deletion. The object will only be deleted once the finalizers have run successfully. Finalizers can be used for garbage collection of resources. For example, you can define a finalizer to clean up any related resources before deleting the target resource. Finalizers can also be used to prevent accidental deletion of resources. "},{"title":"Example​","type":1,"pageTitle":"Resource Finalizers","url":"/docs/operator-sdk/finalizers#example","content":"public class ExampleFinalizer : IResourceFinalizer&lt;V1ExampleEntity&gt; { public async Task FinalizeAsync(V1ExampleEntity resource) { // Run finalizer for given entity. } }  "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/docs/operator-sdk/getting-started","content":"","keywords":"operator sdk getting started"},{"title":"Installation​","type":1,"pageTitle":"Getting Started","url":"/docs/operator-sdk/getting-started#installation","content":"dotnet add package Neon.Kube.Operator --prerelease  "},{"title":"How to use​","type":1,"pageTitle":"Getting Started","url":"/docs/operator-sdk/getting-started#how-to-use","content":""},{"title":"Program.cs​","type":1,"pageTitle":"Getting Started","url":"/docs/operator-sdk/getting-started#programcs","content":"public static partial class Program { public static async Task Main(string[] args) { var operator = KubernetesOperatorHost .CreateDefaultBuilder(args) .ConfigureNeonKube() // for operators running in NeonKUBE clusters. .UseStartup&lt;Startup&gt;() .Build(); await operator.RunAsync(); } }  "},{"title":"Startup.cs​","type":1,"pageTitle":"Getting Started","url":"/docs/operator-sdk/getting-started#startupcs","content":"public void ConfigureServices(IServiceCollection services) { services.AddKubernetesOperator(); } public void Configure(IApplicationBuilder app) { app.UseKubernetesOperator(); }  By default, all Controllers, Finalizers and Webhooks in your assembly will be added to the operator. "},{"title":"Resource Controllers","type":0,"sectionRef":"#","url":"/docs/operator-sdk/controllers","content":"","keywords":"operator sdk crd crds custom resource resource controller"},{"title":"Introduction​","type":1,"pageTitle":"Resource Controllers","url":"/docs/operator-sdk/controllers#introduction","content":"Resource Controllers are called when Kubernetes resources are created, modified, or deleted. They are configured to watch specific resource types, have methods for responding to such updates. "},{"title":"Reconciler​","type":1,"pageTitle":"Resource Controllers","url":"/docs/operator-sdk/controllers#reconciler","content":"Reconcilers are responsible for bringing the actual state of a resource to the desired state, which is expressed in the Custom Resource object specification. When a reconcile event is triggered, it is always passed the current state of the resource to be reconciled. A reconciler must be idempotent A function is said to be idempotent if it can be applied multiple times without changing the result beyond the initial application. "},{"title":"Triggers​","type":1,"pageTitle":"Resource Controllers","url":"/docs/operator-sdk/controllers#triggers","content":"Reconcile is triggered by the following events: A resource has been created.A resource has been updated.A resource failed reconciliation and was requeued.An object with anownerReferenceto the resource. "},{"title":"Example​","type":1,"pageTitle":"Resource Controllers","url":"/docs/operator-sdk/controllers#example","content":"In its simplest form, this is what the ReconcileAsync method looks like: public Task&lt;ResourceControllerResult&gt; ReconcileAsync(V1ExampleEntity resource) { // TODO: apply logic return ResourceControllerResult.Ok(); }  "},{"title":"Status Updates​","type":1,"pageTitle":"Resource Controllers","url":"/docs/operator-sdk/controllers#status-updates","content":"StatusModifiedAsync is called when the status of a resource has changed. public async Task StatusModifiedAsync(V1ExampleEntity resource) { // react to status update }  "},{"title":"Requeuing​","type":1,"pageTitle":"Resource Controllers","url":"/docs/operator-sdk/controllers#requeuing","content":"When a reconcile event throws an exception, it will be requeued. "},{"title":"Global defaults​","type":1,"pageTitle":"Resource Controllers","url":"/docs/operator-sdk/controllers#global-defaults","content":"Global defaults can be configured by setting ResourceManagerOptions inConfigureOperator. var k8s = KubernetesOperatorHost .CreateDefaultBuilder() .ConfigureOperator(configure =&gt; { configure.ResourceManagerOptions = new ResourceManagerOptions() { ErrorMaxRequeueInterval = TimeSpan.FromMinutes(1), ErrorMaxRetryCount = 10, ErrorMinRequeueInterval = TimeSpan.FromSeconds(1) }; }) .UseStartup&lt;Startup&gt;() .Build(); await = k8s.RunAsync();  "},{"title":"Controller specific​","type":1,"pageTitle":"Resource Controllers","url":"/docs/operator-sdk/controllers#controller-specific","content":"Controllers are configurable by passing ResourceManagerOptions to your controller when calling AddController in Startup.cs. note To do this, assembly scanning should be disabled or add the[Controller(Ignore = true)] attribute to the controller. using Neon.Kube.Operator; using Neon.Kube.Operator.ResourceManager; public void ConfigureServices(IServiceCollection services) { services.AddKubernetesOperator() .AddController&lt;ExampleController&gt;( options: new ResourceManagerOptions() { ErrorMaxRequeueInterval = TimeSpan.FromMinutes(1), ErrorMaxRetryCount = 10, ErrorMinRequeueInterval = TimeSpan.FromSeconds(1) }); }  "},{"title":"Manual requeue​","type":1,"pageTitle":"Resource Controllers","url":"/docs/operator-sdk/controllers#manual-requeue","content":"public Task&lt;ResourceControllerResult&gt; ReconcileAsync(V1ExampleEntity resource) { return ResourceControllerResult.RequeueEvent(TimeSpan.FromSeconds(10)); }  "},{"title":"Leader election​","type":1,"pageTitle":"Resource Controllers","url":"/docs/operator-sdk/controllers#leader-election","content":""},{"title":"Events​","type":1,"pageTitle":"Resource Controllers","url":"/docs/operator-sdk/controllers#events","content":"The following methods are provided for reacting to leadership events. public async Task OnPromotionAsync() { // Controller was promoted to leader. } public async Task OnDemotionAsync() { // Controller is no longer leader. } public async Task OnNewLeaderAsyncc(string identity) { // There is a new leader. The identity of the new leader is given. }  "},{"title":"Configuring​","type":1,"pageTitle":"Resource Controllers","url":"/docs/operator-sdk/controllers#configuring","content":"Leader election can be configured by setting LeaderElectionConfig when adding a controller via AddController in Startup.cs. note To do this, assembly scanning should be disabled or add the[Controller(Ignore = true)] attribute to the controller. using Neon.Kube; using Neon.Kube.Operator; public void ConfigureServices(IServiceCollection services) { services.AddKubernetesOperator() .AddController&lt;ExampleController&gt;( leaderConfig: new LeaderElectionConfig( k8s: K8s, @namespace: &quot;default&quot;, leaseName: $&quot;example.controller&quot;, identity: Pod.Name)) }  "},{"title":"Filtering​","type":1,"pageTitle":"Resource Controllers","url":"/docs/operator-sdk/controllers#filtering","content":"Filtering resources can be achieved by applyingfield selectorsand/orlabel selectors. Both label selectors and field selectors are comma-separated key=valuestrings. "},{"title":"Field Selectors​","type":1,"pageTitle":"Resource Controllers","url":"/docs/operator-sdk/controllers#field-selectors","content":"Field selectors can be set either by the Controller attribute, or by theResourceManagerOptions.FieldSelector property. [Controller(FieldSelector = &quot;metadata.name=my-resource&quot;)] public class ExampleController : IResourceController&lt;ExampleResource&gt;  "},{"title":"Label Selectors​","type":1,"pageTitle":"Resource Controllers","url":"/docs/operator-sdk/controllers#label-selectors","content":"Field selectors can be set either by the Controller attribute, or by theResourceManagerOptions.FieldSelector property. [Controller(LabelSelector = &quot;neonkube.io/managed-by=my-operator,neonkube.io/controlled-by=example-controller&quot;)] public class ExampleController : IResourceController&lt;ExampleResource&gt;  "},{"title":"Dependent Resources​","type":1,"pageTitle":"Resource Controllers","url":"/docs/operator-sdk/controllers#dependent-resources","content":"In many cases, an operator creates a bunch of Kubernetes resources in the cluster, as a result of reconciling a Resource. For instance, the etcd-operator creates two services and a number of pods for a single EtcdCluster CR. In this case, all the Kubernetes resources created by the operator for a CR is defined as dependent resources. The etcd-operator may want to watch the pods that it created in case it needs to reconcile again. DependentResources can be defined by adding an annotation to the Controller. using Neon.Kube.Operator; using Neon.Kube.Operator.Controller; using Neon.Kube.Resources; [DependentResource&lt;V1Pod&gt;] [DependentResource&lt;V1Service&gt;] public class EtcdController : IResourceController&lt;V1EtcdCluster&gt; { // Controller implementation. }  Controllers are configurable by setting DependentResources inResourceManagerOptions when adding a controller via AddController inStartup.cs. note To do this, assembly scanning should be disabled or add the[Controller(Ignore = true)] attribute to the controller. using Neon.Kube.Operator; using Neon.Kube.Operator.ResourceManager; using Neon.Kube.Resources; public void ConfigureServices(IServiceCollection services) { services.AddKubernetesOperator() .AddController&lt;EtcdController&gt;( options: new ResourceManagerOptions() { DependentResources = new List&lt;IDependentResource&gt;() { new DependentResource&lt;V1Pod&gt;(), new DependentResource&lt;V1Service&gt;() } }); }  "},{"title":"Monitoring","type":0,"sectionRef":"#","url":"/docs/operator-sdk/monitoring","content":"","keywords":"operator sdk metrics prometheus grafana observability"},{"title":"Metrics​","type":1,"pageTitle":"Monitoring","url":"/docs/operator-sdk/monitoring#metrics","content":"By default, operators will emit a collection of performance metrics for each controller. "},{"title":"Grafana Dashboard​","type":1,"pageTitle":"Monitoring","url":"/docs/operator-sdk/monitoring#grafana-dashboard","content":"Here is a sample dashboard to get started:operator-dashboard.json "},{"title":"Tracing​","type":1,"pageTitle":"Monitoring","url":"/docs/operator-sdk/monitoring#tracing","content":"To enable OpenTelemetry tracing, there is aAddKubernetesOperatorInstrumentation extension method to theTracerProviderBuilder class. using Neon.Kube.Operator; using OpenTelemetry; using OpenTelemetry.Resources; var builder = Sdk.CreateTracerProviderBuilder() .SetResourceBuilder(ResourceBuilder.CreateDefault() .AddService(&quot;my-operator&quot;, serviceVersion: &quot;1.0.0&quot;)) .AddKubernetesOperatorInstrumentation() .AddOtlpExporter( options =&gt; { options.ExportProcessorType = ExportProcessorType.Batch; options.BatchExportProcessorOptions = new BatchExportProcessorOptions&lt;Activity&gt;(); options.Endpoint = new Uri(&quot;otel-collector-uri&quot;); options.Protocol = OpenTelemetry.Exporter.OtlpExportProtocol.Grpc; }) .Build();  "},{"title":"RBAC","type":0,"sectionRef":"#","url":"/docs/operator-sdk/rbac","content":"","keywords":"operator sdk rbac security access control"},{"title":"Introduction​","type":1,"pageTitle":"RBAC","url":"/docs/operator-sdk/rbac#introduction","content":"Role-based access control (RBAC) is a method of regulating access to your Operator. When debugging, the Operator will automatically apply configured RBAC rules, and use them. This allows you to verify configuration before deployment. "},{"title":"Configuring RBAC rules​","type":1,"pageTitle":"RBAC","url":"/docs/operator-sdk/rbac#configuring-rbac-rules","content":"RBAC rules are configured by appling RbacRule annotations to classes within the Operator project. They can be applied to any class including Controllers,Finalizers and Webhooks. "},{"title":"Example​","type":1,"pageTitle":"RBAC","url":"/docs/operator-sdk/rbac#example","content":"using Neon.Kube.Operator.Rbac; using Neon.Kube.Resources; namespace ExampleOperator { /// &lt;summary&gt; /// Example controller /// &lt;/summary&gt; [RbacRule&lt;V1ExampleEntity&gt;( Verbs = RbacVerb.All, Scope = EntityScope.Cluster)] [RbacRule&lt;V1ServiceAccount&gt;( Verbs = RbacVerb.List | RbacVerb.Create, Scope = EntityScope.Cluster)] [RbacRule&lt;V1Pod&gt;( Verbs = RbacVerb.Get | RbacVerb.Watch | RbacVerb.Patch, Scope = EntityScope.Namespaced)] [RbacRule&lt;V1ConfigMap&gt;( Verbs = RbacVerb.Get | RbacVerb.Watch, Scope = EntityScope.Namespaced)] public class ExampleController : IResourceController&lt;V1ExampleEntity&gt; { // your controller implementation } }  "},{"title":"Generating RBAC manifests​","type":1,"pageTitle":"RBAC","url":"/docs/operator-sdk/rbac#generating-rbac-manifests","content":"Operators can generate RBAC manifests which can be applied using Helm, Kustomize, etc. operator.exe generate rbac  "},{"title":"Local Development","type":0,"sectionRef":"#","url":"/docs/operator-sdk/webhooks/local-dev","content":"","keywords":"operator sdk webhooks tunnel development environment"},{"title":"Visual Studio Dev Tunnels​","type":1,"pageTitle":"Local Development","url":"/docs/operator-sdk/webhooks/local-dev#visual-studio-dev-tunnels","content":"When running your Operator in Visual Studio, it's possible to create a tunnel usingVisual Studio Dev Tunnels. This will allow you to debug your webhooks live in Visual Studio. "},{"title":"Prerequisites​","type":1,"pageTitle":"Local Development","url":"/docs/operator-sdk/webhooks/local-dev#prerequisites","content":"DownloadVisual Studio 2022 version 17.4.You will also need to be signed into Visual Studio to create and use dev tunnels.Enable the dev tunnels preview feature. You can find this atTools -&gt; Options -&gt;Environment -&gt; Preview Features, and select the option Enable dev tunnels for Web Applications.  "},{"title":"Setup​","type":1,"pageTitle":"Local Development","url":"/docs/operator-sdk/webhooks/local-dev#setup","content":"Add the following properties to your profile in launchsettings.json &quot;devTunnelEnabled&quot;: true, &quot;devTunnelAccess&quot;: &quot;Public&quot;  That's it! The rest will be taken care of when you start your Operator. "},{"title":"Writing Unit Tests","type":0,"sectionRef":"#","url":"/docs/operator-sdk/testing/unit-testing","content":"","keywords":"operator sdk test unit testing"},{"title":"Example​","type":1,"pageTitle":"Writing Unit Tests","url":"/docs/operator-sdk/testing/unit-testing#example","content":"using k8s.Models; using Neon.Kube.Xunit.Operator; using Xunit; public class Test_Operator : IClassFixture&lt;TestOperatorFixture&gt; { private TestOperatorFixture fixture; public Test_Operator(TestOperatorFixture fixture) { this.fixture = fixture; fixture.Operator.AddController&lt;TestDatabaseController&gt;(); fixture.RegisterType&lt;V1StatefulSet&gt;(); fixture.RegisterType&lt;V1Service&gt;(); fixture.Start(); } [Fact] public async Task CreateStatefulSetAsync() { fixture.ClearResources(); var controller = fixture.Operator.GetController&lt;TestDatabaseController&gt;(); var resource = new V1TestDatabase() { Metadata = new V1ObjectMeta() { Name = &quot;test-database&quot;, NamespaceProperty = &quot;test&quot; }, Spec = new TestDatabaseSpec() { Image = &quot;foo/bar:latest&quot;, Servers = 3, VolumeSize = &quot;1Gi&quot; } }; await controller.ReconcileAsync(resource); var statefulsets = fixture.Resources.OfType&lt;V1StatefulSet&gt;(); var services = fixture.Resources.OfType&lt;V1Service&gt;(); Assert.Equal(2, fixture.Resources.Count); // verify statefulset Assert.Contains(statefulsets, r =&gt; r.Metadata.Name == resource.Name()); Assert.Equal(resource.Spec.Servers, statefulsets.Single().Spec.Replicas); // verify service Assert.Contains(services, r =&gt; r.Metadata.Name == resource.Name()); } }  "},{"title":"Mutating Webhooks","type":0,"sectionRef":"#","url":"/docs/operator-sdk/webhooks/mutating-webhooks","content":"","keywords":"operator sdk resource webhook admission control dynamic admission control mutating webhook"},{"title":"Introduction​","type":1,"pageTitle":"Mutating Webhooks","url":"/docs/operator-sdk/webhooks/mutating-webhooks#introduction","content":"Mutating webhooks are most frequently used for setting default values. They can modify objects by creating a patch that will be sent back in the admission response. "},{"title":"Example Mutating Webhook​","type":1,"pageTitle":"Mutating Webhooks","url":"/docs/operator-sdk/webhooks/mutating-webhooks#example-mutating-webhook","content":"[Webhook( name: &quot;pod-policy.neonkube.io&quot;, admissionReviewVersions: &quot;v1&quot;, failurePolicy: &quot;Ignore&quot;)] [WebhookRule( apiGroups: V1Pod.KubeGroup, apiVersions: V1Pod.KubeApiVersion, operations: AdmissionOperations.Create | AdmissionOperations.Update, resources: V1Pod.KubePluralName, scope: &quot;*&quot;)] public class PodWebhook : IMutatingWebhook&lt;V1Pod&gt; { private bool modified = false; public async Task&lt;MutationResult&gt; CreateAsync(V1Pod entity, bool dryRun) { if (modified) { return await Task.FromResult(MutationResult.Modified(entity)); } return await Task.FromResult(MutationResult.NoChanges()); } public async Task&lt;MutationResult&gt; UpdateAsync(V1Pod entity, V1Pod oldEntity, bool dryRun) { if (modified) { return await Task.FromResult(MutationResult.Modified(entity)); } return await Task.FromResult(MutationResult.NoChanges()); } }  "},{"title":"Validating Webhooks","type":0,"sectionRef":"#","url":"/docs/operator-sdk/webhooks/validating-webhooks","content":"","keywords":"operator sdk resource webhook admission control dynamic admission control validating webhook"},{"title":"Introduction​","type":1,"pageTitle":"Validating Webhooks","url":"/docs/operator-sdk/webhooks/validating-webhooks#introduction","content":"Validating webhooks can be used to perform validations that go beyond the capabilities of OpenAPI schema validation. A validating Webhook can reject the request, but it cannot modify the object received in the request. "},{"title":"Example​","type":1,"pageTitle":"Validating Webhooks","url":"/docs/operator-sdk/webhooks/validating-webhooks#example","content":"[Webhook( name: &quot;pod-policy.neonkube.io&quot;, admissionReviewVersions: &quot;v1&quot;, failurePolicy: &quot;Ignore&quot;)] [WebhookRule( apiGroups: V1Pod.KubeGroup, apiVersions: V1Pod.KubeApiVersion, operations: AdmissionOperations.Create | AdmissionOperations.Update, resources: V1Pod.KubePluralName, scope: &quot;*&quot;)] public class PodWebhook : IValidatingWebhook&lt;V1Pod&gt; { public async Task&lt;ValidationResult&gt; CreateAsync(V1Pod entity, bool dryRun) { if (entity.Metadata.Name == &quot;invalid-entity&quot;) { return ValidationResult.Fail(statusCode: 500, statusMessage: &quot;Entity name is not valid.&quot;); } return ValidationResult.Success(); } public async Task&lt;ValidationResult&gt; UpdateAsync(V1Pod entity, V1Pod oldEntity, bool dryRun) { if (entity.Metadata.Name == &quot;invalid-entity&quot;) { return ValidationResult.Fail(statusCode: 500, statusMessage: &quot;Entity name is not valid.&quot;); } return ValidationResult.Success(); } }  "},{"title":"Neon CLI Reference","type":0,"sectionRef":"#","url":"/docs/references/neon-cli","content":"Neon CLI Reference neon is a command-line tool used to configure and manage the nodes of a neonKUBE cluster. It is included with neonDESKTOP. Run neon to see the list of available commands. &gt; neon neon [v1.24.0] Copyright c 2005-2023 by NEONFORGE LLC. All rights reserved. USAGE: neon [OPTIONS] COMMAND [ARG...] NEON KUBECTL COMMANDS: [neon-cli] supports all standard kubectl commands like (more help below): neon apply -f my-manifest.yaml NEON CLUSTER LIFE-CYCLE COMMANDS: neon cluster check neon cluster dashboard neon cluster health neon cluster info neon cluster islocked neon cluster lock neon cluster prepare CLUSTER-DEF neon cluster pause [OPTIONS] neon cluster delete [OPTIONS] neon cluster reset [OPTIONS] neon cluster setup [OPTIONS] root@CLUSTER-NAME neon cluster start neon cluster stop [OPTIONS] neon cluster unlock neon cluster verify [CLUSTER-DEF] neon login COMMAND neon logout NEON HELM COMMANDS: The neon-cli supports all standard Helm commands by prefixing them with [helm], like: neon helm install -f my-values.yaml my-redis ./redis NEON UTILITY COMMANDS: neon tool generate iso SOURCE-FOLDER ISO-PATH neon tool password COMMAND neon tool vault COMMAND neon tool version [-n] [--git] [--minimum=VERSION] CLUSTER MANAGEMENT ARGUMENTS: CLUSTER-DEF - Path to a cluster definition file. This is optional for some commands when logged in COMMAND - Subcommand and arguments NOTE: Command line arguments and options may include references to profile values, secrets and environment variables, like: ${profile:NAME} - profile value ${secret:NAME} - &quot;password&quot; property value of NAME secret ${secret:NAME:SOURCE} - &quot;password&quot; property value of NAME secret at SOURCE ${secret:NAME[PROPERTY} - PROPERTY value from NAME secret ${secret:NAME[PROPERTY]:SOURCE} - PROPERTY value from NAME secret at SOURCE ${env:NAME} - environment variable For Linux, you'll need to surround these references with single quotes to prevent Bash from interpreting them as Bash variable references. =============================================================================== kubectl controls the Kubernetes cluster manager. Find more information at: https://kubernetes.io/docs/reference/kubectl/overview/ Basic Commands (Beginner): create Create a resource from a file or from stdin expose Take a replication controller, service, deployment or pod and expose it as a new Kubernetes service run Run a particular image on the cluster set Set specific features on objects Basic Commands (Intermediate): explain Get documentation for a resource get Display one or many resources edit Edit a resource on the server delete Delete resources by file names, stdin, resources and names, or by resources and label selector Deploy Commands: rollout Manage the rollout of a resource scale Set a new size for a deployment, replica set, or replication controller autoscale Auto-scale a deployment, replica set, stateful set, or replication controller Cluster Management Commands: certificate Modify certificate resources. cluster-info Display cluster information top Display resource (CPU/memory) usage cordon Mark node as unschedulable uncordon Mark node as schedulable drain Drain node in preparation for maintenance taint Update the taints on one or more nodes Troubleshooting and Debugging Commands: describe Show details of a specific resource or group of resources logs Print the logs for a container in a pod attach Attach to a running container exec Execute a command in a container port-forward Forward one or more local ports to a pod proxy Run a proxy to the Kubernetes API server cp Copy files and directories to and from containers auth Inspect authorization debug Create debugging sessions for troubleshooting workloads and nodes Advanced Commands: diff Diff the live version against a would-be applied version apply Apply a configuration to a resource by file name or stdin patch Update fields of a resource replace Replace a resource by file name or stdin wait Experimental: Wait for a specific condition on one or many resources kustomize Build a kustomization target from a directory or URL. Settings Commands: label Update the labels on a resource annotate Update the annotations on a resource completion Output shell completion code for the specified shell (bash, zsh or fish) Other Commands: alpha Commands for features in alpha api-resources Print the supported API resources on the server api-versions Print the supported API versions on the server, in the form of &quot;group/version&quot; config Modify kubeconfig files plugin Provides utilities for interacting with plugins version Print the client and server version information Usage: kubectl [flags] [options] Use &quot;kubectl &lt;command&gt; --help&quot; for more information about a given command. Use &quot;kubectl options&quot; for a list of global command-line options (applies to all commands). ","keywords":"introduction"}]