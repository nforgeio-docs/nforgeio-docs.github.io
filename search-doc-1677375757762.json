[{"title":"Intro","type":0,"sectionRef":"#","url":"/docs/intro","content":"Intro","keywords":"neonforge"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/neonkube","content":"Introduction NeonKUBE is a Full Stack Kubernetes Distribution which includes Kubernetes Core, opensource and custom add-ons, as well as a other tools like neon-desktop and neon-cli. Not only can NeonKUBE clusters be deployed directly on local servers or the cloud, you can also deploy full stack clusters on a laptop or workstation. NeonKUBE requires a 4-core computer with at least 16 GiB RAM and about 75 GiB of free disk space when deploying a local cluster. The local cluster runs on a Hyper-V virtual machine with 8 GiB RAM and currently Kubernetes and NeonKUBE are consuming about 5.5 gig of memory, leaving 2.5 gig for user applications. NeonKUBE clusters can be suspended at any time to quickly release this memory when the cluster isn’t needed. This only takes a few seconds.","keywords":"neonkube"},{"title":"Installation","type":0,"sectionRef":"#","url":"/docs/neonkube/getting-started/installation","content":"","keywords":"neon-desktop neonkube"},{"title":"Requirements​","type":1,"pageTitle":"Installation","url":"/docs/neonkube/getting-started/installation#requirements","content":""},{"title":"Operating System​","type":1,"pageTitle":"Installation","url":"/docs/neonkube/getting-started/installation#operating-system","content":"Windows HomeWindows Professional Future: MacOSLinux "},{"title":"Hardware​","type":1,"pageTitle":"Installation","url":"/docs/neonkube/getting-started/installation#hardware","content":"RAM: 16GB Virtual Machine has 8GBNeonKube consumes ~5.5 GB CPU: 4Disk: 64GB "},{"title":"Windows​","type":1,"pageTitle":"Installation","url":"/docs/neonkube/getting-started/installation#windows","content":"Installing NeonKUBE on windows goes here "},{"title":"Hello World Example","type":0,"sectionRef":"#","url":"/docs/neonkube/how-to-guides/hello-world","content":"Hello World Example This tutorial demonstrates how to deploy a simple application to a NeonKUBE cluster. Clone demo repository​ git clone https://github.com/nforgeio/neonKUBE-demos.git set DEMO_DIR=C:\\&lt;CURRENT-DIRECTORY&gt;\\neonKUBE-demos set CLUSTER_ID=&lt;YOUR_CLUSTER_ID&gt; Build Hello World image​ In this step, we build the hello-world container image and publish it to the local cluster registry. cd %DEMO_DIR%\\Services\\hello-world dotnet publish hello-world.csproj -c Release -o .\\bin\\Release\\net6.0\\publish unix-text docker-entrypoint.sh docker build -t neon-registry.%CLUSTER_ID%.neoncluster.io/library/hello-world . docker push neon-registry.%CLUSTER_ID%.neoncluster.io/library/hello-world Deploy hello World​ Here we are creating a Kubernetes Deployment from the yaml manifest. cd %DEMO_DIR% cp helloworld.yaml &quot;%TEMP%\\helloworld.yaml&quot; neon-build replace &quot;%TEMP%\\helloworld.yaml&quot; &quot;$&lt;CLUSTER_ID&gt;&quot; %CLUSTER_ID% neon apply -f &quot;%TEMP%\\helloworld.yaml&quot; rm &quot;%TEMP%\\helloworld.yaml&quot; Hello World can now be accessed at https://hello-world.CLUSTER-ID.neoncluster.io. Replace CLUSTER-ID with your cluster ID.","keywords":"neonkube"},{"title":"Best Practices","type":0,"sectionRef":"#","url":"/docs/neonkube/operator-sdk/best-practices","content":"","keywords":"neonkube kubernetes operator sdk resource controllers"},{"title":"Implementing a Reconciler​","type":1,"pageTitle":"Best Practices","url":"/docs/neonkube/operator-sdk/best-practices#implementing-a-reconciler","content":""},{"title":"Idempotency​","type":1,"pageTitle":"Best Practices","url":"/docs/neonkube/operator-sdk/best-practices#idempotency","content":"Reconcile is called for every event received from the Controller, which could be multiple times for the same resource. This includes listing all resources the first time the Operator starts or restarts. It is important that reconciliation is idempotent. A function is said to be idempotent if it can be applied multiple times without changing the result beyond the initial application. "},{"title":"Reconcile All Resources All the Time​","type":1,"pageTitle":"Best Practices","url":"/docs/neonkube/operator-sdk/best-practices#reconcile-all-resources-all-the-time","content":"Reconciliation can be triggered from many different event sources. It could be tempting to check the event to try to figure out what needs reconciling, but this is considered to be an anti-pattern for Operators. Because of the distributed nature of Kubernetes, it's possible that the Operator did not receive all events and in this situation making assumptions about the current state could be dangerous. For this reason it is best practice to reconcile all resources all the time. "},{"title":"Owner References​","type":1,"pageTitle":"Best Practices","url":"/docs/neonkube/operator-sdk/best-practices#owner-references","content":"Dependent objects created by the Reconciler should have an Owner Reference that references their owner resource. This will allow Kubernetes to clean up resources when the parent resource is deleted. info Cross-namespace owner references are disallowed by design. Namespaced dependents can specify cluster-scoped or namespaced owners. A namespaced owner must exist in the same namespace as the dependent. If it does not, the owner reference is treated as absent, and the dependent is subject to deletion once all owners are verified absent. Cluster-scoped dependents can only specify cluster-scoped owners. In v1.20+, if a cluster-scoped dependent specifies a namespaced kind as an owner, it is treated as having an unresolvable owner reference, and is not able to be garbage collected. For cross-namespace garbage collection, use a Finalizer. Owner references can be created by calling the MakeOwnerReference() extension method on any resource. var pod = new V1Pod().Initialize() pod.AddOwnerReference(resource.MakeOwnerReference());  "},{"title":"Resource Finalizers","type":0,"sectionRef":"#","url":"/docs/neonkube/operator-sdk/finalizers","content":"","keywords":"neonkube kubernetes operator sdk resource finalizers"},{"title":"Introduction​","type":1,"pageTitle":"Resource Finalizers","url":"/docs/neonkube/operator-sdk/finalizers#introduction","content":"Finalizers are namespaced keys that tell Kubernetes to wait until specific conditions are met before it fully deletes resources marked for deletion. When you tell Kubernetes to delete an object that has finalizers specified for it, the Kubernetes API will mark the object for deletion. The object will only be deleted once the finalizers have run successfully. Finalizers can be used for garbage collection of resources. For example, you can define a finalizer to clean up any related resources before deleting the target resource. Finalizers can also be used to prevent accidental deletion of resources. "},{"title":"Example​","type":1,"pageTitle":"Resource Finalizers","url":"/docs/neonkube/operator-sdk/finalizers#example","content":"public class ExampleFinalizer : IResourceFinalizer&lt;V1ExampleEntity&gt; { public async Task FinalizeAsync(V1ExampleEntity resource) { // Run finalizer for given entity. } }  "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/docs/neonkube/operator-sdk/getting-started","content":"","keywords":"neonkube kubernetes operator sdk getting started"},{"title":"Installation​","type":1,"pageTitle":"Getting Started","url":"/docs/neonkube/operator-sdk/getting-started#installation","content":"dotnet add package Neon.Kube.Operator  "},{"title":"How to use​","type":1,"pageTitle":"Getting Started","url":"/docs/neonkube/operator-sdk/getting-started#how-to-use","content":""},{"title":"Program.cs​","type":1,"pageTitle":"Getting Started","url":"/docs/neonkube/operator-sdk/getting-started#programcs","content":"public static partial class Program { public static async Task Main(string[] args) { var operator = KubernetesOperatorHost .CreateDefaultBuilder(args) .ConfigureNeonKube() // for operators running in NeonKUBE clusters. .UseStartup&lt;Startup&gt;() .Build(); await operator.RunAsync(); } }  "},{"title":"Startup.cs​","type":1,"pageTitle":"Getting Started","url":"/docs/neonkube/operator-sdk/getting-started#startupcs","content":"public void ConfigureServices(IServiceCollection services) { services.AddKubernetesOperator(); } public void Configure(IApplicationBuilder app) { app.UseKubernetesOperator(); }  By default, all Controllers, Finalizers and Webhooks in your assembly will be added to the operator. "},{"title":"Monitoring","type":0,"sectionRef":"#","url":"/docs/neonkube/operator-sdk/monitoring","content":"","keywords":"neonkube kubernetes operator sdk metrics prometheus grafana"},{"title":"Metrics​","type":1,"pageTitle":"Monitoring","url":"/docs/neonkube/operator-sdk/monitoring#metrics","content":"By default, operators will emit a collection of performance metrics for each controller. "},{"title":"Grafana Dashboard​","type":1,"pageTitle":"Monitoring","url":"/docs/neonkube/operator-sdk/monitoring#grafana-dashboard","content":"Here is a sample dashboard to get started: operator-dashboard.json "},{"title":"Tracing​","type":1,"pageTitle":"Monitoring","url":"/docs/neonkube/operator-sdk/monitoring#tracing","content":"To enable OpenTelemetry tracing, there is a AddKubernetesOperatorInstrumentation extension method to the TracerProviderBuilder class. using Neon.Kube.Operator; using OpenTelemetry; using OpenTelemetry.Resources; var builder = Sdk.CreateTracerProviderBuilder() .SetResourceBuilder(ResourceBuilder.CreateDefault() .AddService(&quot;my-operator&quot;, serviceVersion: &quot;1.0.0&quot;)) .AddKubernetesOperatorInstrumentation() .AddOtlpExporter( options =&gt; { options.ExportProcessorType = ExportProcessorType.Batch; options.BatchExportProcessorOptions = new BatchExportProcessorOptions&lt;Activity&gt;(); options.Endpoint = new Uri(&quot;otel-collector-uri&quot;); options.Protocol = OpenTelemetry.Exporter.OtlpExportProtocol.Grpc; }) .Build();  "},{"title":"RBAC","type":0,"sectionRef":"#","url":"/docs/neonkube/operator-sdk/rbac","content":"","keywords":"neonkube kubernetes operator sdk resource rbac"},{"title":"Introduction​","type":1,"pageTitle":"RBAC","url":"/docs/neonkube/operator-sdk/rbac#introduction","content":"Role-based access control (RBAC) is a method of regulating access to your Operator. When debugging, the Operator will automatically apply configured RBAC rules, and use them. This allows you to verify configuration before deployment. "},{"title":"Configuring RBAC rules​","type":1,"pageTitle":"RBAC","url":"/docs/neonkube/operator-sdk/rbac#configuring-rbac-rules","content":"RBAC rules are configured by appling RbacRule annotations to classes within the Operator project. They can be applied to any class includingControllers, Finalizers and Webhooks. "},{"title":"Example​","type":1,"pageTitle":"RBAC","url":"/docs/neonkube/operator-sdk/rbac#example","content":"using Neon.Kube.Operator.Rbac; using Neon.Kube.Resources; namespace ExampleOperator { /// &lt;summary&gt; /// Example controller /// &lt;/summary&gt; [RbacRule&lt;V1ExampleEntity&gt;(Verbs = RbacVerb.All, Scope = EntityScope.Cluster)] [RbacRule&lt;V1ServiceAccount&gt;(Verbs = RbacVerb.List | RbacVerb.Create, Scope = EntityScope.Cluster)] [RbacRule&lt;V1Pod&gt;(Verbs = RbacVerb.Get | RbacVerb.Watch | RbacVerb.Patch, Scope = EntityScope.Namespaced)] [RbacRule&lt;V1ConfigMap&gt;(Verbs = RbacVerb.Get | RbacVerb.Watch, Scope = EntityScope.Namespaced)] public class ExampleController : IResourceController&lt;V1ExampleEntity&gt; { // your controller implementation } }  "},{"title":"Generating RBAC manifests​","type":1,"pageTitle":"RBAC","url":"/docs/neonkube/operator-sdk/rbac#generating-rbac-manifests","content":"Operators can generate RBAC manifests which can be applied using Helm, Kustomize, etc. operator.exe generate rbac  "},{"title":"Local Development","type":0,"sectionRef":"#","url":"/docs/neonkube/operator-sdk/webhooks/local-dev","content":"","keywords":"neonkube kubernetes operator sdk resource webhooks tunnel"},{"title":"Visual Studio Dev Tunnels​","type":1,"pageTitle":"Local Development","url":"/docs/neonkube/operator-sdk/webhooks/local-dev#visual-studio-dev-tunnels","content":"When running your Operator in Visual Studio, it's possible to create a tunnel using Visual Studio Dev Tunnels. This will allow you to debug your webhooks live in Visual Studio. "},{"title":"Prerequisites​","type":1,"pageTitle":"Local Development","url":"/docs/neonkube/operator-sdk/webhooks/local-dev#prerequisites","content":"Download Visual Studio 2022 version 17.4.You will also need to be signed into Visual Studio to create and use dev tunnels.Enable the dev tunnels preview feature. You can find this at Tools -&gt; Options -&gt; Environment -&gt; Preview Features, and select the option Enable dev tunnels for Web Applications.  "},{"title":"Setup​","type":1,"pageTitle":"Local Development","url":"/docs/neonkube/operator-sdk/webhooks/local-dev#setup","content":"Add the following properties to your profile in launchsettings.json &quot;devTunnelEnabled&quot;: true, &quot;devTunnelAccess&quot;: &quot;Public&quot;  That's it! The rest will be taken care of when you start your Operator. "},{"title":"Resource Controllers","type":0,"sectionRef":"#","url":"/docs/neonkube/operator-sdk/controllers","content":"","keywords":"neonkube kubernetes operator sdk resource controllers"},{"title":"Introduction​","type":1,"pageTitle":"Resource Controllers","url":"/docs/neonkube/operator-sdk/controllers#introduction","content":"Resource Controllers are called when Kubernetes resources are created, modified, or deleted. They are configured to watch specific resource types, have methods for responding to such updates. "},{"title":"Reconciler​","type":1,"pageTitle":"Resource Controllers","url":"/docs/neonkube/operator-sdk/controllers#reconciler","content":"Reconcilers are responsible for bringing the actual state of a resource to the desired state, which is expressed in the Custom Resource object specification. When a reconcile event is triggered, it is always passed the current state of the resource to be reconciled. A reconciler must be idempotent A function is said to be idempotent if it can be applied multiple times without changing the result beyond the initial application. "},{"title":"Triggers​","type":1,"pageTitle":"Resource Controllers","url":"/docs/neonkube/operator-sdk/controllers#triggers","content":"Reconcile is triggered by the following events: A resource has been created.A resource has been updated.A resource failed reconciliation and was requeued.An object with an ownerReferenceto the resource. "},{"title":"Example​","type":1,"pageTitle":"Resource Controllers","url":"/docs/neonkube/operator-sdk/controllers#example","content":"In its simplest form, this is what the ReconcileAsync method looks like: public Task&lt;ResourceControllerResult&gt; ReconcileAsync(V1ExampleEntity resource) { // TODO: apply logic return ResourceControllerResult.Ok(); }  "},{"title":"Status Updates​","type":1,"pageTitle":"Resource Controllers","url":"/docs/neonkube/operator-sdk/controllers#status-updates","content":"StatusModifiedAsync is called when the status of a resource has changed. public async Task StatusModifiedAsync(V1ExampleEntity resource) { // react to status update }  "},{"title":"Requeuing​","type":1,"pageTitle":"Resource Controllers","url":"/docs/neonkube/operator-sdk/controllers#requeuing","content":"When a reconcile event throws an exception, it will be requeued. "},{"title":"Global defaults​","type":1,"pageTitle":"Resource Controllers","url":"/docs/neonkube/operator-sdk/controllers#global-defaults","content":"Global defaults can be configured by setting ResourceManagerOptions in ConfigureOperator. var k8s = KubernetesOperatorHost .CreateDefaultBuilder() .ConfigureOperator(configure =&gt; { configure.ResourceManagerOptions = new ResourceManagerOptions() { ErrorMaxRequeueInterval = TimeSpan.FromMinutes(1), ErrorMaxRetryCount = 10, ErrorMinRequeueInterval = TimeSpan.FromSeconds(1) }; }) .UseStartup&lt;Startup&gt;() .Build(); await = k8s.RunAsync();  "},{"title":"Controller specific​","type":1,"pageTitle":"Resource Controllers","url":"/docs/neonkube/operator-sdk/controllers#controller-specific","content":"Controllers are configurable by passing ResourceManagerOptions to your controller when calling AddController in Startup.cs. note To do this, assembly scanning should be disabled or add the [Controller(Ignore = true)] attribute to the controller. using Neon.Kube.Operator; using Neon.Kube.Operator.ResourceManager; public void ConfigureServices(IServiceCollection services) { services.AddKubernetesOperator() .AddController&lt;ExampleController&gt;( options: new ResourceManagerOptions() { ErrorMaxRequeueInterval = TimeSpan.FromMinutes(1), ErrorMaxRetryCount = 10, ErrorMinRequeueInterval = TimeSpan.FromSeconds(1) }); }  "},{"title":"Manual requeue​","type":1,"pageTitle":"Resource Controllers","url":"/docs/neonkube/operator-sdk/controllers#manual-requeue","content":"public Task&lt;ResourceControllerResult&gt; ReconcileAsync(V1ExampleEntity resource) { return ResourceControllerResult.RequeueEvent(TimeSpan.FromSeconds(10)); }  "},{"title":"Leader election​","type":1,"pageTitle":"Resource Controllers","url":"/docs/neonkube/operator-sdk/controllers#leader-election","content":""},{"title":"Events​","type":1,"pageTitle":"Resource Controllers","url":"/docs/neonkube/operator-sdk/controllers#events","content":"The following methods are provided for reacting to leadership events. public async Task OnPromotionAsync() { // Controller was promoted to leader. } public async Task OnDemotionAsync() { // Controller is no longer leader. } public async Task OnNewLeaderAsyncc(string identity) { // There is a new leader. The identity of the new leader is given. }  "},{"title":"Configuring​","type":1,"pageTitle":"Resource Controllers","url":"/docs/neonkube/operator-sdk/controllers#configuring","content":"Leader election can be configured by setting LeaderElectionConfig when adding a controller via AddController in Startup.cs. note To do this, assembly scanning should be disabled or add the [Controller(Ignore = true)] attribute to the controller. using Neon.Kube; using Neon.Kube.Operator; public void ConfigureServices(IServiceCollection services) { services.AddKubernetesOperator() .AddController&lt;ExampleController&gt;( leaderConfig: new LeaderElectionConfig( k8s: K8s, @namespace: &quot;default&quot;, leaseName: $&quot;example.controller&quot;, identity: Pod.Name)) }  "},{"title":"Filtering​","type":1,"pageTitle":"Resource Controllers","url":"/docs/neonkube/operator-sdk/controllers#filtering","content":"Filtering resources can be achieved by applying field selectors and/or label selectors. Both label selectors and field selectors are comma-separated key=value strings. "},{"title":"Field Selectors​","type":1,"pageTitle":"Resource Controllers","url":"/docs/neonkube/operator-sdk/controllers#field-selectors","content":"Field selectors can be set either by the Controller attribute, or by the ResourceManagerOptions.FieldSelector property. [Controller(FieldSelector = &quot;metadata.name=my-resource&quot;)] public class ExampleController : IResourceController&lt;ExampleResource&gt;  "},{"title":"Label Selectors​","type":1,"pageTitle":"Resource Controllers","url":"/docs/neonkube/operator-sdk/controllers#label-selectors","content":"Field selectors can be set either by the Controller attribute, or by the ResourceManagerOptions.FieldSelector property. [Controller(LabelSelector = &quot;neonkube.io/managed-by=my-operator,neonkube.io/controlled-by=example-controller&quot;)] public class ExampleController : IResourceController&lt;ExampleResource&gt;  "},{"title":"Dependent Resources​","type":1,"pageTitle":"Resource Controllers","url":"/docs/neonkube/operator-sdk/controllers#dependent-resources","content":"In many cases, an operator creates a bunch of Kubernetes resources in the cluster, as a result of reconciling a Resource. For instance, the etcd-operator creates two services and a number of pods for a single EtcdCluster CR. In this case, all the Kubernetes resources created by the operator for a CR is defined as dependent resources. The etcd-operator may want to watch the pods that it created in case it needs to reconcile again. DependentResources can be defined by adding an annotation to the Controller. using Neon.Kube.Operator; using Neon.Kube.Operator.Controller; using Neon.Kube.Resources; [DependentResource&lt;V1Pod&gt;] [DependentResource&lt;V1Service&gt;] public class EtcdController : IResourceController&lt;V1EtcdCluster&gt; { // Controller implementation. }  Controllers are configurable by setting DependentResources in ResourceManagerOptions when adding a controller via AddController in Startup.cs. note To do this, assembly scanning should be disabled or add the [Controller(Ignore = true)] attribute to the controller. using Neon.Kube.Operator; using Neon.Kube.Operator.ResourceManager; using Neon.Kube.Resources; public void ConfigureServices(IServiceCollection services) { services.AddKubernetesOperator() .AddController&lt;EtcdController&gt;( options: new ResourceManagerOptions() { DependentResources = new List&lt;IDependentResource&gt;() { new DependentResource&lt;V1Pod&gt;(), new DependentResource&lt;V1Service&gt;() } }); }  "},{"title":"Mutating Webhooks","type":0,"sectionRef":"#","url":"/docs/neonkube/operator-sdk/webhooks/mutating-webhooks","content":"","keywords":"neonkube kubernetes operator sdk resource mutating webhooks"},{"title":"Introduction​","type":1,"pageTitle":"Mutating Webhooks","url":"/docs/neonkube/operator-sdk/webhooks/mutating-webhooks#introduction","content":"Mutating webhooks are most frequently used for setting default values. They can modify objects by creating a patch that will be sent back in the admission response. "},{"title":"Example Mutating Webhook​","type":1,"pageTitle":"Mutating Webhooks","url":"/docs/neonkube/operator-sdk/webhooks/mutating-webhooks#example-mutating-webhook","content":"[Webhook( name: &quot;pod-policy.neonkube.io&quot;, admissionReviewVersions: &quot;v1&quot;, failurePolicy: &quot;Ignore&quot;)] [WebhookRule( apiGroups: V1Pod.KubeGroup, apiVersions: V1Pod.KubeApiVersion, operations: AdmissionOperations.Create | AdmissionOperations.Update, resources: V1Pod.KubePluralName, scope: &quot;*&quot;)] public class PodWebhook : IMutatingWebhook&lt;V1Pod&gt; { private bool modified = false; public async Task&lt;MutationResult&gt; CreateAsync(V1Pod entity, bool dryRun) { if (modified) { return await Task.FromResult(MutationResult.Modified(entity)); } return await Task.FromResult(MutationResult.NoChanges()); } public async Task&lt;MutationResult&gt; UpdateAsync(V1Pod entity, V1Pod oldEntity, bool dryRun) { if (modified) { return await Task.FromResult(MutationResult.Modified(entity)); } return await Task.FromResult(MutationResult.NoChanges()); } }  "},{"title":"Intro","type":0,"sectionRef":"#","url":"/docs/neonsdk","content":"Intro NeonSDK is an open source project released under the Apache 2.0 license. This project includes several class general purpose libraries published as nuget packages (known as the Neon libraries).","keywords":"neonsdk"},{"title":"Neon CLI Reference","type":0,"sectionRef":"#","url":"/docs/references/neon-cli","content":"Neon CLI Reference","keywords":"neonkube"},{"title":"Validating Webhooks","type":0,"sectionRef":"#","url":"/docs/neonkube/operator-sdk/webhooks/validating-webhooks","content":"","keywords":"neonkube kubernetes operator sdk resource validating webhooks"},{"title":"Introduction​","type":1,"pageTitle":"Validating Webhooks","url":"/docs/neonkube/operator-sdk/webhooks/validating-webhooks#introduction","content":"Validating webhooks can be used to perform validations that go beyond the capabilities of OpenAPI schema validation. A validating Webhook can reject the request, but it cannot modify the object received in the request. "},{"title":"Example​","type":1,"pageTitle":"Validating Webhooks","url":"/docs/neonkube/operator-sdk/webhooks/validating-webhooks#example","content":"[Webhook( name: &quot;pod-policy.neonkube.io&quot;, admissionReviewVersions: &quot;v1&quot;, failurePolicy: &quot;Ignore&quot;)] [WebhookRule( apiGroups: V1Pod.KubeGroup, apiVersions: V1Pod.KubeApiVersion, operations: AdmissionOperations.Create | AdmissionOperations.Update, resources: V1Pod.KubePluralName, scope: &quot;*&quot;)] public class PodWebhook : IValidatingWebhook&lt;V1Pod&gt; { public async Task&lt;ValidationResult&gt; CreateAsync(V1Pod entity, bool dryRun) { if (entity.Metadata.Name == &quot;invalid-entity&quot;) { return ValidationResult.Fail(statusCode: 500, statusMessage: &quot;Entity name is not valid.&quot;); } return ValidationResult.Success(); } public async Task&lt;ValidationResult&gt; UpdateAsync(V1Pod entity, V1Pod oldEntity, bool dryRun) { if (entity.Metadata.Name == &quot;invalid-entity&quot;) { return ValidationResult.Fail(statusCode: 500, statusMessage: &quot;Entity name is not valid.&quot;); } return ValidationResult.Success(); } }  "}]